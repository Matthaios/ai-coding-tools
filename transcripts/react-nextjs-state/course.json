{
  "title": "State Management at Scale in React & Next.js",
  "slug": "react-nextjs-state",
  "url": "https://frontendmasters.com/courses/react-nextjs-state/",
  "instructor": "David Khourshid",
  "lessons": [
    {
      "number": 1,
      "title": "Introduction",
      "slug": "introduction",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/introduction/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Welcome to the State Management at Scale workshop at Frontend Masters. My name is David Khourshid and I'll be your instructor today. So, first of all, what do I mean by state management at scale? Does it mean like lots of users, a thousand components, or like just a million lines of code? \n\n[00:00:21] And actually scale, at least when we're talking about state management at scale is isn't really about size. It's actually all about maintainability and iteration speed as your app evolves. So the questions that you have to ask yourself are, can you add features without breaking existing ones? Can your team members contribute confidently to your code base and can you actually debug issues quickly? \n\n[00:00:45] So that's what I mean by scale. And so by the end of today, after this workshop, you're going to have patterns that scale on hopefully all three dimensions. First of all, features. So you want to be able to add new functionality by extending your code base and not modifying too much if you can help it. \n\n[00:01:05] You also want to have a good understanding of the code base for your teammates, because usually when you're working on a big project, it's not just you, you're working with your teammates. And so you want to have everyone coding in a very similar way, preventing merge conflicts and more importantly, preventing confusion, whether you're new to the code base or you've been coding in it for many, many years. \n\n[00:01:30] The third one which I'm going to really focus on in this workshop is complexity. And so that's state management that you can debug and understand, especially as you add features, change features, fix bugs, et cetera. All right, so first of all, who is this workshop for? This workshop is for React developers, and honestly, any sort of a front end developer, whether you're working in React Vue, Angular, doesn't matter. \n\n[00:01:58] But our focus today is going to be on a React next JS app. But the idea is that we're going to be going beyond the basics of React state management. You probably already know your basic hooks, such as use date, use effects, use reference, and you might know the other hooks too, like useContext, useReducer, and maybe you've used some of the other ones like UseMemo, et cetera. \n\n[00:02:24] And you have worked in large or small React applications, some of which are in production, and some of them you might have been using React for a while. So you might have legacy code bases that use class components or hopefully newer ones that use hooks instead of classes. \n\n[00:02:43] And you attending this workshop, you've worked with a team and most of you have gone through honestly, like all of these common struggles of managing states in a large application. So you might have tried state management libraries or maybe you've invented your own solutions. I've seen a lot of code bases where basically they said, we're not going to use a third party state management library. \n\n[00:03:08] We're going to either try to use react hooks as much as we can, or we're going to try to build our own thing. And even those sort of end up in disaster in the long run. You have also felt the pain with dealing with an ever growing number of features and bugs in your application. \n\n[00:03:26] And maybe you have run into things like the dreaded infinite loop and use effect. I know I have lots of times, or even worse, when you have a lot of multiple chain use effects and you're like, okay, there's a bug. I don't know what is causing this. So you have to sort of debug every single use effect and see what is causing the other one to trigger. \n\n[00:03:48] And it sort of feels like a Rube Goldberg machine instead of a state machine. And it becomes just near impossible to debug. And so we're going to be talking about that later too."
    },
    {
      "number": 2,
      "title": "Course Overview",
      "slug": "course-overview",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/course-overview/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: What are we going to get out of this workshop? We're going to learn core principles of state management that will help you architect these solutions that scale with application complexity. And even though that we're going to be working on a React Next JS app, all of these concepts that you learned today, they're going to be applicable to any front end application. \n\n[00:00:20] Regardless of which framework you use. We're going to keep it high level and general. So we're not going to be going in depth into specialized hooks or the nuances of how Next JS does things, or the most shiny newest features of React. There's actually a lot of great front end masters courses already on that and I highly encourage you to check those out. \n\n[00:00:45] But we are going to at the same time be looking at common React pitfalls and anti patterns that you may have run into. And in general, we're going to be looking at opportunities to improve your code base and make it more clear, understandable and maintainable. Because at the end of the day, we want to model and manage our state in a way that is easy to maintain, it's easy to update, and it's easy for our team to contribute to. \n\n[00:01:13] And so the skills and concepts that you learn today are meant to be evergreen, they're meant to be, like I said, general, and they're meant to be skills that stay true whether React evolves, you use different libraries or maybe you work in different frameworks. All right, so the structure of this workshop, you should all have the repo. \n\n[00:01:36] It's GitHub.com davidkpiano Frontend masters state Workshop this workshop is split up into many lessons and exercises like you could see on the screen. Hopefully we'll be going through all of them and we're going to be working on many of them together. And I'm also going to hand a lot of these exercises off to you to start off and work on. \n\n[00:02:02] All of these lessons are designed to teach you general state management concepts and there's many that are actually also going to teach you specific patterns and anti patterns for React applications. So I strongly encourage you to apply these lessons to your own code bases or even other open source React projects. \n\n[00:02:23] Because I guarantee that even though we have exercises specific to this workshop, you are going to find things in your code bases where it's like, wow, that pattern applies here. So I could actually refactor my code base and make these changes. Also going to be showing you some third party libraries that you can use to help out and I do want you to understand the principles behind these third party libraries and the motivations for why you would use them. \n\n[00:02:52] But again, I'm not telling you that every single application you use needs to have all of these tools. That's absolutely not necessary. And especially for state management, you do not need to use third party libraries for state management. Like many developers, I have been through the struggles of managing state in large applications. \n\n[00:03:16] I worked in multi step forums where we did a lot of bespoke PHP and jQuery with very complex flows and async data handling. And I was doing this back in the angular and backbone days and unfortunately we weren't even allowed to use those frameworks. So when I was a junior developer I was also a visual learner and I really wanted to make sense of all this spaghetti logic. \n\n[00:03:40] So I started learning about these things called state machines and even state charts. And I created a library called XState. And XState is a library for managing state machines and state charts. And I do have a couple of courses on frontend masters for XState if you want to learn about it. \n\n[00:03:58] But that is not what we're going to be doing in this workshop. Instead we're actually going to be taking the main principles of event driven state management and that's honestly at the core of state machines and state charts. And we're going to be applying those principles to our React applications. \n\n[00:04:17] What is our purpose in doing that? First of all, we want to create these apps with understandability at its core. Again, you want to be able to understand your logic. You want your team members to understand what all of the logic in your application. You also want to be able to understand all of the use cases and all of the edge cases and train yourself to think of everything that can possibly happen in your application to prevent impossible states and impossible transitions. \n\n[00:04:47] We also want to be able to work in legacy applications so that we could understand and refactor messy legacy code so that it becomes a lot easier to add new features and fix bugs. And it's 2025, we have AI powered coding tools. In fact, our coding is going to be done in cursor. \n\n[00:05:07] And honestly, when your app is organized and your app logic is clear to a human, it's also very clear to an LLM. So if you're using a lot of AI assistance, then having clarity in your code and showing the LLM, this is my intention for this feature is really going to help. \n\n[00:05:26] Just to explain the workshop a little bit more so the structure, we have a bunch of exercises and they're all prefixed with Exercise Dash and so the first one that we're going to be starting with is the anti patterns exercise and you're going to see a few files here so you're going to see a page. \n\n[00:05:47] This is going to be the main page that you're going to be working on. You're going to see a readme that includes the contents of this lesson as well as a description of the exercise. And we're also going to have a scratch pad where you could basically just write whatever you want. \n\n[00:06:03] You could also do whatever you want in page tsx especially if you clone the repo, it's yours. So you could do whatever you want. And if you want to peek into the solution or I should probably say a solution again there's no one size fits all for state management so this is one of many possible solutions depending on your requirements for the app. \n\n[00:06:26] But if you want to peek in here while you're working on these exercises then this is an example solution that will help you."
    },
    {
      "number": 3,
      "title": "Deriving State Anti-Pattern",
      "slug": "deriving-state-anti-pattern",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/deriving-state-anti-pattern/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: The first thing that we're going to be talking about is actually basic react state anti patterns. It's the beginning of the workshop, so we're not going to be getting too deep into philosophy or principles or anything like that. Instead, I want to cover three very important state ante patterns that I see in pretty much any project that I work in or I have looked at in reaction. \n\n[00:00:26] The first one is deriving states. So we want to learn when we should calculate values instead of storing them. And this is a pattern that I see all the time. So the way that you recognize this pattern is that you might see a use state and a use effect combination where the use effect is the one that's calculating new states. \n\n[00:00:51] And this seems really convenient because the whole way that useEffect works with dependency arrays is that whenever any value in the dependency array changes, it's going to execute something inside that useEffect function. And so you might think, okay, this is a great place for me to calculate some new states, but it's actually not. \n\n[00:01:11] This is one of those fun ones where you could just go into a code base and just start refactoring your way. So NC pattern scratch. So, for example, let's say that we're going to make a simple app and let's say that we're doing a coffee order app. So I might have orders, setOrders, useState-Order, and these might be just a string for now, or actually they're gonna be orders. \n\n[00:01:48] So let's make a proper order type. And so I also need to import use date. All right, so let's say that we have an order and the order can be for a cappuccino, espresso, latte, mocha, stuff like that in each order has a price, which has a number and also a quantity. \n\n[00:02:15] So you might have seen that like, okay, we have our orders and we probably have some UI to update those orders, but we also want to calculate the total of these orders so we'll have total settotal. And also there's a reason that I do have claw turned on right now. \n\n[00:02:33] It's because it's probably going to suggest the wrong thing, which is great. Claude makes mistakes, just like humans make mistakes, and other AI powered coding assistants too. So you can see immediately it's trying to do a useEffect, why? Because it's going to calculate the totals in that useEffect. \n\n[00:02:52] So I mean, raise your hand if you've seen this pattern in your code base. Probably everyone. Yeah, it's just everywhere. So what is so wrong with this? Well, we have an unnecessary use effect, which is going to cause an unnecessary render when the orders change. And really, this is derived state. \n\n[00:03:13] So I want you to recognize this pattern over here. We have a useState, and then we have a useEffect that's setting that used state. So what's the alternative here? Well, we can actually just completely get rid of that useEffect and just set the totals directly. And so this is really all that you need to do. \n\n[00:03:37] Then, of course, you could show the orders, show the total amounts, and you might have some UI for setting the orders too. But the point is that we are calculating this derived state directly inside render. And I know what some of you might be thinking, too. You might be thinking, okay, yeah, this is great. \n\n[00:03:56] So I'm just going to wrap this in a UseMemo and go. Hold on. Before you start using UseMemo, just start with this. Calculate states directly in render when it can be derived. We have our source of truth here, which is the orders, and we have the total, which can be derived from orders. \n\n[00:04:17] Now, this is an obvious example, but as you'll see in the exercise, some of these might be a little bit hidden and harder to recognize, but once you see it, you really can't unsee it. Claude's even recommending that I use Memo, but the idea is that you can compute states directly in render and then use that."
    },
    {
      "number": 4,
      "title": "useState & Redundant State Anti-Pattern",
      "slug": "usestate-redundant-state-anti-pattern",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/usestate-redundant-state-anti-pattern/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: The other one is using refs. So, using refs is actually good when we have values that don't mean to cause a RE render. So you could think of component states as being two parts states or values that should cause RE renders because they are related to the actual UI that's being rendered, or states that is not related to renders. \n\n[00:00:25] It's sort of internal and something that you want to keep internal. So, for example, this timer, we might have a timer ID and a way to set the timer id, and the reason that we have it external. Because I know some of you might be saying, okay, the proper way to do this is put it in a useEffect and then clear, but we might have some way of externally stopping the timer, and so we have to handle that. \n\n[00:00:52] So that might be one instance where you would see the timer ID being external outside of a useEffect. But the idea is the same. We have this timer ID that has nothing to do with the rendering at all. So what should we do instead? We should put it in a ref, and that way the logic is a lot simpler and we're not going to trigger a RE render when we update that timer ID. \n\n[00:01:20] Again, this is one of those things that might not seem like a problem in your code base, but it does keep your code a lot simpler and it is just a better pattern. You want to limit the amount of RE renders and you also want to simplify the actual logic. \n\n[00:01:38] In short, use refs when you want something. Refs aren't just for DOM elements or things like that. They can also be for any sort of value that does not need to cause a RE render. And the third one, this might be trickier to find, but I promise you, this is something that's really going to improve the way that you handle state in your components, and that is working with redundant states. \n\n[00:02:08] So, just like with derived states, we want a single source of truth for all of our data. And so with derived state, we saw that in like, okay, a total can be computed from a list of items. But like I said, sometimes it's not so clear. So, an example with redundant state that I see a lot, let's say that we have a hotel selection. \n\n[00:02:29] So we have a bunch of hotels that we're looking at, and we want the user to be able to select a hotel. What we would typically do is say, okay, they want to select a hotel. It makes sense in our minds. We're going to let them choose a hotel and then set the selected hotel directly. \n\n[00:02:46] The problem with this is that we are creating redundant data. So we have a selected hotel, which is an object that's exactly the same shape inside the hotels over here. And instead we could actually derive that data. So I'll just show you how this works. Copy this over. \n\n[00:03:12] All right, so instead of having the selected hotel, what I want you to do instead is have the selected hotel id, because we could derive the selected hotel from that. So if we change this to set selected hotel id now, now this becomes a string instead. So we're no longer doing that. \n\n[00:03:36] And so now we could just select the hotel id, which is a string, change this to the hotel id, and then we could apply our first pattern, which is deriving that state. So const selectedhotel, and then we could just find the hotel based on its id. Now, this is actually really useful because let's say that you're selecting a hotel, and you also want these hotel items to dynamically change. \n\n[00:04:11] They might change for some reason. The price might shoot up, or a date might become unavailable. You might be fetching this data from an external source. So the problem with selecting the entire hotel is, is that because it's no longer derived from that data, and instead it's redundant data, you might be showing stale data. \n\n[00:04:30] So that's one of the biggest dangers of selecting the entire object. And this just makes the logic, both reading and updating a lot simpler, because now all you have to worry about is an id."
    },
    {
      "number": 5,
      "title": "State Anti-Pattern Exercise",
      "slug": "state-anti-pattern-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/state-anti-pattern-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: And so what we're going to be doing is we're going to jump into the exercise. So what I want you to do is go to anti patterns and go to page TSX and there's going to be a lot of different exercises and hopefully this should be pretty quick for you to do. \n\n[00:00:22] The point is to build the muscle memory to actually, to actually avoid these any patterns and simplify these components based on what we've learned, which is the proper use of refs deriving states instead of duplicating it and also avoiding redundant states. So let's go ahead and take a few minutes and jump into this and let's get started. \n\n[00:00:57] All right, so let's go through all of these anti patterns that again, I'm sure that you've seen in your code bases. And again, these exercises are meant to get the muscle memory in your hands of recognizing these anti patterns and fixing them so that you could do it in your own code base. \n\n[00:01:14] And I recommend for this exercise and all of the other exercises, try to do it in the code bases that you have access to or at least try to identify or search for them. Honestly, if you search for use date in your code base, you're going to see a lot of these. \n\n[00:01:31] But okay, so let's take a look at this first one. Filter destinations. Again, we see this combination useState and useEffect hook where we're setting the filter destinations. What we could do instead is I am going to do const oops filtered destinations and I'm just going to directly compute that in render. \n\n[00:01:58] Now I can get rid of this use date and I got rid of the other useEffect and it still works with each of these you could go and just make sure that everything still works. All right, and so for the other exercises, it's all very similar too. Again, instead of setting directly just const total cost and then get rid of that useEffect and get rid of that state. \n\n[00:02:30] The more code you delete, the better. This is a very satisfying one to do just because the pattern will hopefully stand out to you like a sore thumb and then you can just immediately do it. This one is a tiny bit more complicated, but only because there's more code over here. \n\n[00:02:50] Still not a problem. We could do const available dates and get rid of this use dates, get rid of the use effect because we're already going to have the updated booked dates inside. Okay, so now let's go take a look at some other patterns. So for example, let's see, I wanted to see a ref- 1. \n\n[00:03:23] Okay, here's a good one. So this is the same timer example that we were talking about, you know, with a booking timer. Instead of this, let's use a Ref. So const timerIdRef = useRef. And then we now have access to that timerIdRef via timeridRef.current. And then so instead of setting it directly over here, we can just say timerIdRef.current equals that Id. \n\n[00:03:58] And then we could do the same thing over here. Since we're clearing the timer, we could say timer ID ref current is null and then we could just clean up the rest. So we could say this should be timer ID ref current. Let's give this a proper type of NodeJS.Timeout or null. \n\n[00:04:24] And then let's also set timerIdRef.currents. We'll set that to null and we'll also change these too for the sake of time. I'm just using cursor, but it's essentially the same thing. We are replacing timer ID with the timer ID ref.current and so our effect is now no longer going to change change multiple times. \n\n[00:04:52] So, same thing with the scroll position tracker. We could, instead of keeping track of the last scroll position in use dates, we could use a ref. So const last, oops, LastScrollPositionRef = useRef and we'll give it a number type. And this is just going to be zero. So now we can get rid of this useState and we could update the Ref instead. \n\n[00:05:21] So LastScrollPositionRef.current = currentPosition over here. And then so set last scroll position and then we could just update the rest. So we are going to get that. And now we no longer need this use or actually no, we still need that use effect, but we no longer need anything in there, just because the effect does not need to rerun whenever the scroll position changes or sorry, whenever the last scroll position changes. \n\n[00:06:03] So I want to skip ahead to the hotel selection one that we talked about. So again, this is a case where we have redundant states. We are selecting a hotel instead of selecting the, you know, the hotel id, which makes things a lot simpler. So instead of this, we could just select the hotel ID and then set this to set selected hotel id. \n\n[00:06:31] So instead of trying to grab the type of the hotel, this is just going to be a string. And so instead of this, we are going to be handling the hotel ID instead, which is going to be a string. And so we could set the hotel ID to that hotel id and now the selected hotel is going to be derived from the selected hotel id. \n\n[00:06:56] So Const selected hotel equals we have our hotels already, so hotels and we're going to find the hotel where the hotel ID is equal to the selected hotel id. And so now we have derived states and we're preventing just having redundant states. And so a similar thing is going to be done with things like, you know, these other exercises over here, this is a pretty common one where we have our user profile from somewhere, but we're also trying to manage the state of each of these components. \n\n[00:07:37] And so, you know, we're trying to set the username and all of the other fields over there. >> Speaker 2: We just wanna use userProfile.name. >> David Khourshid: Yeah, yeah, yeah, >> Speaker 2: yeah. As the we don't even need to use use state, we could just reference the state from up above. >> David Khourshid: Yeah, exactly, that's exactly right. \n\n[00:07:58] So instead of doing all this, yeah, you could basically just use user profile name. You don't need to pull it in from me to these useSates. So then here we have user profile name, email preferences, budget and preferences traveltype. A bit of a contrived example, but yeah, that just goes to show you that if you can avoid redundant states, then you don't really need to have all of those multiple use dates handling that. \n\n[00:08:36] So that's a solution to a few of these exercises and the other ones just follow suits in the same way. Any questions about any of these warm up exercises that we did? Yes, >> Speaker 3: one thing I try to do is especially when it comes to static values, for instance the user profile, rather than place the whole object inside of use state, especially if that entity isn't going to be change or modified, since we don't have a set callback or function passed in here as well, that to just leave it outside of the scope of the function. \n\n[00:09:20] So instantiate it above the function and then just reference it inside kind of a closure, right? Where we're referencing it outside of the function, I would imagine. Would you recommend that over the practice that's currently happening there? >> David Khourshid: Yes, I would. And again, this is a contrived example. \n\n[00:09:40] So ideally this user profile would come from props or if it does come from somewhere else, you can bring it in as a closure. Although I would say just be wary of closures just because you want your function to be self contained and easily testable. So if you were trying to extract this component out and test it, then that closure data might not be available for whatever reason. \n\n[00:10:06] So it might be something where you would pass it in via context or pass it in via props but yes, the idea is that in this case the user profile isn't changing, so it does not need to be inside of a use dates, which is another important thing. \n\n[00:10:21] I've seen use dates where there is no setter at all, so it sort of makes them a little bit useless. I think the most important takeaway here is that you should try to derive state as much as possible. So we're going to be seeing that in other exercises as well, where that principle really comes into play."
    },
    {
      "number": 6,
      "title": "Incidental vs. Accidental Complexity",
      "slug": "incidental-vs-accidental-complexity",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/incidental-vs-accidental-complexity/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: So now we're going to jump to the second lesson, which is on diagrams. So you might be asking yourself like, what do diagrams really have to do with this? I thought that we're going to be working in React, and the main point of, or the main motivation of modeling your application is to separate incidental versus accidental complexity. \n\n[00:00:27] And so what is the difference between incidental and accidental complexity? Incidental complexity is unavoidable. This is the irreducible complexity that comes from the problem domain that you're working in itself. So it is how things are supposed to update the different flows, where data comes in from, etc. It doesn't matter which language or framework or libraries you're working on, this incidental complexity is going to stay exactly the same and you really can't do much to reduce it. \n\n[00:01:01] But that's not a huge problem, as we'll see. The second part is accidental complexity. So this is the complexity that we ourselves introduce from the implementation choices we make, the different tools or libraries or frameworks that we use. Earlier, someone mentioned as part of their struggles with state management that for example, Redux. \n\n[00:01:25] And this could happen with other tools too. But Redux, at least the original Redux sort of mandated that you have so many different files. I remember when I worked in Redux you had this actions file and then you had your reducer file and then you had maybe another file for constants and maybe another file for selectors. \n\n[00:01:43] And that I would call accidental complexity. Because this is again self inflicted. We chose Redux, at least the old version. Redux toolkit is a lot better now, but it introduced a lot of complexity where we basically have to play nice with the tools we use rather than focusing on the actual problem domain that we're working in. \n\n[00:02:07] Another one that was mentioned was many use dates. So we have all of these use date calls and then we have to juggle them and also chaining of useEffects. So our decision to use many useEffects actually contributes to accidental complexity over incidental complexity. And so this is why I think it is super important to model your application. \n\n[00:02:31] So what do I mean by modeling? I don't mean just trying to use some sort of advanced tool to specifically model or do anything like UML, just to make sure that you have everything perfect before you start working. Just because, like we talked about, that's not how code works, that's not how our projects work. \n\n[00:02:52] We might be jumping into legacy projects where that kind of documentation doesn't exist. So that's why I really want to emphasize quick documentation, where you're basically just writing down in whatever is the most like, the fastest, most optimal way of describing your application logic. Just documenting the different flows, how your data works, etc. \n\n[00:03:19] And so that's why in this exercise, we have a flows ND file. It's empty but this is something where I want you all to brainstorm and work on after we learn about the different diagrams."
    },
    {
      "number": 7,
      "title": "Essential Modeling Diagrams",
      "slug": "essential-modeling-diagrams",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/essential-modeling-diagrams/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: There's three essential diagrams that I think that are important for everyone to learn and to use in their application. Again, we're not going to be going full uml. There's many different diagram types, but there's three in particular that really help you think about the incidental complexity in your application. \n\n[00:00:18] The first is entity relationship diagrams. Now some of you might have worked with this before in databases. And the point of this kind of diagram is to model your data, so documents your data model and the relationship between the different entities in your data. So for example, if we're creating a booking system, we might have a user. \n\n[00:00:40] Of course most apps have users. We might have flights as well, where this is just a raw list of flights data that we have, and also hotels too. And then we have bookings. Now this is where we get into primary keys and foreign keys. But all that means is that this entity belongs to or is related to another entity. \n\n[00:01:05] So in this case, a booking might be related to a specific flight or a specific hotel. And there's also the concept of relationships where something can be related to something else and there's a different degree to which they're related. So one thing can have many of the other thing or you could have a many to many relationship as well. \n\n[00:01:28] There's just different ways of modeling your data. Now, I wouldn't say that you should use a strict tool or framework for doing this. Just list out all of the different entities you have and put it down. Put down all of the properties and also put down how they relates to each other. \n\n[00:01:48] So the main point I want to make here with entity relationship diagrams is that it's not strictly for databases. It also really helps you model the data in your front end application too. My preferred tool for this, I really like using dbdiagram IO. It's a very simple tool to use and it has a nice, it has a nice DSL over here which again very simple. \n\n[00:02:18] You have different entities which they call tables. I'll zoom in a little bit here. Then you can model the different properties and the different relationships between each of the entities. You could drag it around and you could include this as a visual in your application just to show these are all of the different bits of data that we're going to be representing and, and this is how they all connect together. \n\n[00:02:46] So the second tool, or sorry, the second kind of diagram that I really enjoy using is sequence diagrams. So if I go down here, sequence diagrams, they document the flow between different parts of your application. So let's Say that you're searching for flights or something like that. You have the UI and then you have also a flight search. \n\n[00:03:14] It could be a service or something like that. But the idea is that your UI needs to communicate with this flight search, which can be represented by an async function. But the point is we're sending data from one actor that we call to another actor, and that actor might send, hopefully might send data back. \n\n[00:03:35] And then in the flow of our application, different actors are going to be talking to each other. So let's say that we have an example, a travel booking flow. The UI might call a FlightsearchService, so that again async function and then that will return results. And then once that happens, our UI will now call a different service and then it will show options, then we will pick one of those options. \n\n[00:04:05] And then in the UI we might be talking to our own applications API, which can be a different type of actor, where we would create a booking, update the booking, delete it, et cetera. So just being able to document those interactions between different actors is really going to help clarify how the different parts of your application work, especially when it comes to what happens outside of your react components. \n\n[00:04:32] Now, again, making a sequence diagram, just like making an entity relationship diagram, it doesn't require you to whip out a whiteboard or a diagramming tool. This is something that you could do just in plain text like this. If you do want to use a tool, I really recommend swimlanes. \n\n[00:04:51] Swimlanes is a very easy to use tool that again, it has its own dsl. It's very expressive. You could change the names of the actors over here and it updates immediately, some message here. You could also add notes and things and you could share and export these diagrams and use it within your own code base. \n\n[00:05:16] Now the third one, sort of my specialty again, I have lots of courses on, on state machines, but it's the state's diagram. So this documents, what happens inside of your application. So it's not really about sequence diagrams where one actor is talking to another actor, but instead it is the behavior of a single thing, which I like to call actors. \n\n[00:05:44] So for example, when we're talking about this flight's booking flow, a state diagram might show you the different steps of it. So just to demonstrate here, if we go to states new, let's make a blank canvas over here we might have a flight booking flow, where first it will be flightsearch, and then we'll have our flight results and then we might have the the hotel search, once we pick one. \n\n[00:06:15] So this is select flight. So then we search for a hotel and then on results we have our hotel results and then we're going to go to a confirmation screen. So when we select a hotel we'll go to review screen. And then let's say that just in this example, let's say that this is where we make our payments, then we go to a confirmation screen. \n\n[00:06:47] So looking at this, it might seem pretty linear, it might seem pretty simple. And also I want to ask, are you all familiar with state machines? A little bit? Okay, so for those watching, if you're not, a state machine consists of basically three main things. We have the initial states and all of these states over here. \n\n[00:07:09] And these represents, they could be different screens, different modes of your application, or just different pages. When you're working on multi step forms or flows like that, it's easy to imagine each one of those steps as a state. Then we have transitions. Transitions are what cause one state to go to another state. \n\n[00:07:33] So let's say that we have our flight results and we select a flight. Now we're going to transition to the hotel search page. And so that's what these are, these are events. Events cause state transitions. So the reason that this is useful is, I mean over here it might be simple. \n\n[00:07:55] You might be looking at this and thinking, why can't I just write an array of steps, words like flight search, flight results, hotel search, hotel results, review and confirmation. And that's because especially as your app grows in features, it never remains this simple. So for example, let's say that we want to go back. \n\n[00:08:15] Even the simple act of going back. Now this becomes a directed graph instead of a nice linear structure. Some of you might be thinking, okay, this is a double linked list. But still no, overall it's a directed graph. And then same with hotel search. We could go back and say, okay, we actually want to see the flight results. \n\n[00:08:39] Again, same thing here. We could go back and then review. Of course, we could go back. And then, this is a key point and why I'm doing this. When we made the confirmation, should we be able to go back? Probably not. So that's why it's important to explicitly model these dates. \n\n[00:08:59] And in the review too, we might decide that we want to for instance change our hotel search. So change hotel over here. Or we might want to also change our flight. So we might want to go back to the flight search over here. And now, hopefully you could see that this becomes really a directed graph. \n\n[00:09:24] It's no longer A links list. It's no longer a doubly links list, it's no longer a simple array of steps. But instead this state diagram or flow diagram documents all of the different paths that you have to consider. We could just go through each one and see just all of the different paths that can happen. \n\n[00:09:46] This is useful not only for modeling your application logic, but also for just modeling how you test your application, whether you're doing it manually or, or you're writing end to end tests. So it becomes very clear to see, okay, here's all of the different things that we could do when we're in each state. \n\n[00:10:07] Now, state machines and state diagrams are a really great tool for thinking. They are not something that you necessarily need to include in your entire code base. But again, just being able to document the flows are going to, you know, just pay dividends in your state management. And also you don't necessarily need to just go and diagram these state machines. \n\n[00:10:32] What I like to do sometimes is just write out the different states. So I might say, like starting out here, this is what the user sees. We might not have any data yet, but then they'll fill a form in search and then we will kick off a flight API call and then we're searching for flights. \n\n[00:10:52] So basically we're documenting each of the screens that we see or each of the steps, and we're also documenting what can happen in each step. Those are the two main important things when you're documenting these state diagrams, what state you're in and what can happen in each state. \n\n[00:11:12] So any questions before we move on to the exercise on these three different diagram types? >> Speaker 2: James in the chat just says he's definitely going to take the state machine approach on his next project. >> David Khourshid: That's awesome. So taking the state machine approach on your next project is a really good idea. \n\n[00:11:35] Again, it's not something where you have to tell everyone to use XDATA or to refactor everything as a state machine. Just documenting these flows goes a really, really long way. Someone said we're close to the X date topic here. And yeah, all of this, it is influenced from me thinking about state machines, state charts and working on X dates, but we're not going to be talking about X date specifically in this workshop."
    },
    {
      "number": 8,
      "title": "Application Flow Exercise",
      "slug": "application-flow-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/application-flow-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Okay, so what we're going to do is we're just going to brainstorm. This can be for a hypothetical flights booking app, or it could be for any sort of project that you're working on. We're just going to take a nice calm five minutes, and I want you to just roughly diagram those three different types of diagrams for whatever you're thinking of. \n\n[00:00:24] So, for example, for a flight booking flow, you might want to document the different entities, such as the flights, the hotels, the bookings, etc, or you might want to model something else. Then you would want to model the sequence diagram. So basically, how do the different actors talk to each other? \n\n[00:00:43] So you might have a flight search service, et cetera, and then just briefly document the flow. Again, this does not need to be for this travel travel application. It could be for anything that you're working on or anything that you might want to build yourself. So the point of this is just to get used to thinking about modeling your application state. \n\n[00:01:13] All right, so let's talk about just making a flow for, again, anything you wanted to do. It could be a flight booking flow. Or what I'm actually going to do is I was just on Airbnb, and they have a new design, a new interesting flow for actually booking a place. \n\n[00:01:32] So the idea is that with Airbnb, we have different entities. So first of all, we have the destinations. So we could say we have destinations and we also have different types of. Let's call them homes. So a destination, you know, it might have, like an id, and a home might have, like an id, but also it has a destination id, because these homes don't just roam around, they're fixed to a certain destination. \n\n[00:02:11] And of course, we also have users as well. So a user, they have a name, they have an id. This is just keeping things very simple. But this goes to show you that modeling these three different things can be very simple. You don't have to prescribe to any specific framework or anything like that. \n\n[00:02:33] Then we also have the sequence diagram where once we make a search. So in the ui, we are actually calling out to. Let's just call this the Airbnb. Airbnb search service. And so we are saying, find search results for this query. And the query is like, where, check in, check out, and number of guests. \n\n[00:03:09] Again, I'm doing this in plain language. And so the Airbnb search service. So Airbnb search service will respond with the UI and give us results, and then we will select one. So this is one of those relationships where the UI is basically talking to itself, where we select a home and then we start talking to. \n\n[00:03:38] Let's just call this the Airbnb API, where we will say that we want to make a booking, and then the Airbnb API will go back to the UI and say, okay, here's the payments information. And then the UI will communicate with the payments processor, etc. And then there's the state diagram. \n\n[00:04:03] So what's interesting with Airbnb is it actually has a new flow in that top bar. So it's actually pretty cool. If you go to airbnb.com you select Unexpected state, but you select a destination or yeah, you search destinations like Chicago. Oops, Chicago. And then it immediately transitions you to check in, check out, and then you add your guests and then it takes you to a search page. \n\n[00:04:39] I have no idea what I just searched for, but these houses look really nice. And then it just shows you all of these search results over here. So we can sort of model that flow where first we say, starts with destination, when the destination is input, put in the check in date, then put in the checkout state, then add the number of guests. \n\n[00:05:09] And then when the user presses search, it'll take us to a search results page. The search results will be loading and eventually show up. The user can click on one of the homes and be taken to a details page. They can go back from the details page back to the search page. \n\n[00:05:41] So these don't really look like diagrams right now. They're really rough representations of them. But honestly, just doing this is going to be very impactful for just documenting what happens in your application. And so what we could actually do is, for example, I could ask here, we'll just do a new one. \n\n[00:06:05] I could ask Claude to say, make this a mermaid diagram. And so what it's going to do is it's going to create that diagram and then we could actually copy this and go to something like, I think it's called Mermaid Live. And then we could paste that. And so just from that, we have our representation of the different entities in our application and we could even have it build it out. \n\n[00:06:45] So same thing with this rough sequence diagram. So create a sequence diagram in Mermaid. And also you could ask it to add things I might have missed. And so it's going to generate that, and then we could just use that thinking for a bit. But the main purpose of this is that even though you're writing in plain language, having this is going to be very useful for not only your teammates, but also assistive coding. \n\n[00:07:22] Tools and. Wow. Okay, so it does have a very comprehensive, sort of hard to zoom here, but a comprehensive flow of how the different actors interact with each other. So once we have search results, we request home details, the user initiates booking, and that's going to create a booking request. \n\n[00:07:43] This is probably a lot easier to see in Swimlanes IO, but you get the idea. You have diagrams that you could generate just from the plain text that you write. And so that's why my point in all of this is just write this out. It takes a minimum amount of effort and really you could derive so much from this. \n\n[00:08:07] So let's do one more. We're gonna take this state diagram and make this a mermaid diagram too, because mermaid also supports state diagrams as well. All right, so it's going to generate that. And now that we. Oops, we actually got it. Now that we have that state diagram, we could visualize it in Mermaid. \n\n[00:08:40] And it's a bit broken. See if this does anything. Nope, it requires you to sign in. So let me do something different, okay. Make this an XState machine just for fun. Let's see what happens. It's actually filling in context and things like that. And this actually goes to show you too, that you can generate these machines and not even use them in your own application, but even use them just for visualization. \n\n[00:09:21] So if we go back to state new and we import this, then hopefully, there we go. We have our entire flow documented right here and able to be exported visually. And you saw that it really didn't take much effort to do that. So we're entering the destination, then once we input the destination, we're entering the check in time, then the checkout time, then the number of guests, and then we start searching. \n\n[00:09:54] So we search for homes. It also handles things like if there's an error, we should handle that error and retry. And then we're viewing the search results and then we're viewing the home details and then we go back to the results. All of this information is really important to keep in mind when you're either building your applogic or working on existing legacy apps, where you might not be sure, like, okay, how does this flow work? \n\n[00:10:20] Using these AI powered coding assistants, or even just going through the UI and documenting it yourself makes the application logic so much more clear and it gives you a good foundation for if you need to refactor your code base or you need to add features or fix bugs, you do have that outline. \n\n[00:10:39] So in the same way that we wouldn't build a house without a blueprint, I would not work on an application without documenting it or modeling it, at least at a rough text-only level. So this just shows you how powerful and how easy it is to actually document your application logic. \n\n[00:10:59] I like to have a Flows MD file where you basically have all of this documentation. Again, it doesn't need to be a specific format and it just needs to be somewhere where both your teammates and also the LLMs and AI tools that you use can easily read it and understand at a higher level what's going on. \n\n[00:11:19] So any questions about that? Okay, there's a comment in the chat that they can imagine that hooking something like this up alongside Storybook would really help from documentation of components. Yeah, that's true. And another thing that I really want to emphasize is keeping this inside of your code base has two benefits. \n\n[00:11:50] First of all, like I talked about, both your teammates and AI powered coding tools are going to be able to take that as context and to better understand your code base. And the second thing is it's version controlled alongside your application. If you're storing it somewhere else like notion, that becomes a lot more difficult to do. \n\n[00:12:11] So that's why I like having a Flows MD file just documenting the app logic. Or you could shove it into the readme MD however you and your team prefers."
    },
    {
      "number": 9,
      "title": "Best Practices for State Optimization",
      "slug": "best-practices-for-state-optimization",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/best-practices-for-state-optimization/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: The next two lessons we are going to be working on optimizing state management and really organizing it a lot better. So what I want to start off with are a few principles that I personally believe about state management that really help me shape how I think about managing complex app logic and how State is supposed to update in your application. \n\n[00:00:27] The first one is that events are the real source of truth. If you think about when you make a deposit or make a withdrawal from a bank, how does it keep track of how much money you have in your bank accounts? And how is it sure that it doesn't go out of sync? \n\n[00:00:46] It's not like it's keeping this big object, global object, where it's like, okay, this person has this much money in there. Instead it keeps what they call a ledger. But, you know, in our case, we could refer to it as just an array of events. So basically anything that happens in your application is based on events that change the state over time. \n\n[00:01:11] So like with the bank, you could have a long ledger where it's like you made this deposit and this withdrawal and this deposit, et cetera. And when you reduce all of those things, you come up with, like we talked about in the first exercise, that's derived value. So that's why I say events are the source of truth. \n\n[00:01:33] And that's why it's good to think about things in terms of events. Because since they're the source of truth, it doesn't matter what kind of sources your data are coming from or what is updating what, everything can be considered an event that changes your state. So I remember earlier someone was mentioning that. \n\n[00:01:54] I think it was you, that you were mentioning that you have multiple, multiple places or multiple sources of truth where your data was coming in and updating the TV app. So all of those could be considered an event where the event says something changed and the state will react to that change. \n\n[00:02:16] And by abstracting things in terms of events, you don't really have to think too deeply about what kind of source it is, what kind of library or API you're working with, because at the end of the day, it's just an event. So I really like events too, because events capture a lot more than state's changes. \n\n[00:02:38] And you're going to see this when we get to that dreaded chained useEffect example, because when we're dealing with useEffect, for instance, the way that useEffects just rerun are based on the dependency array. And in the dependency array, we're saying one of these values changed. We don't know which one, but one of them changed. \n\n[00:03:01] So we're missing a lot of information. We're missing the intent, what caused the change, we're missing timing details and we're missing that log of, here's all of the things that led up to this change. It's just this piece of data updated and good luck finding out where it is. \n\n[00:03:21] So events are the real source of truth, whether you're using them explicitly in your apps or not. You could conceptually think that anything that changes in your app is due to some events. Whether it's from the user or from some external source, doesn't matter. The second one might be pretty obvious, but the use of pure functions and immutability. \n\n[00:03:49] I really like using pure functions for AppLogic just because pure functions are the easiest thing to test. And it's also the simplest way of representing your applogic in terms of, when I'm in this date and this event happened, what is the next state going to be? So again, it doesn't matter whether you're working in angular react vue, etc. \n\n[00:04:13] You can represent your core application logic using these pure functions. And you could also represent the way that you derive state as a pure function too. So the core principle of this is really deterministic behavior. You have this pure function that runs deterministically and given the same input, it's always going to produce the same output, but more so, it's easy to test. \n\n[00:04:41] So you could take that pure function and write unit tests for it. And pure functions are also composable. And you can do things like memoizing the results of pure functions pretty reliably. Since everything is self-contained within that function, you know they're deterministic. So you know that if I cache this expensive value, it's always going to be consistent with what the pure function was going to produce. \n\n[00:05:06] So that's why I say try to keep all of your application logic centralized in pure functions. Not a single pure function, but it could be many pure functions. Another principle that I live by is the idea that you should write code as if the framework or the tool or the library or any of the underlying abstractions are just going to change under you. \n\n[00:05:31] Now, we've all worked in large code bases before, and legacy code bases. We know that this is almost never going to happen whether we want to or not. But the idea is that we want to avoid tightly coupling business logic to to framework specific patterns. And this goes hand-in-hand with peer functions for AppLogic. \n\n[00:05:53] We want to separate our logic so that it's easy to test and it's easy to adapt pretty much anywhere. Then, of course, there are state machines for modeling, which combines the idea of events being the real source of truth, first date, and also using pure functions to represent app logic. \n\n[00:06:16] Now again, I'm not saying use state machines everywhere, but thinking about your app in terms of these states can allow you to prevent impossible states and impossible transitions. By an impossible state, I mean, for example, let's say you have an is success and is error. You probably don't want those two things to be true at the same time, but if they're both floating around as you state, then it is very possible that that can be the case. \n\n[00:06:45] Another one that I see very, very commonly, and you probably have seen before too, especially with limited Internet connection, is you might click on a user or click on some search results and you will get a flash of no search results found or this user does not exist. \n\n[00:07:02] And then one second later they pop up magically. And so that's why, thinking of state machines really eliminates those kinds of problems where listen, all of your tests and all of your end to end tests are probably going to pass and the user might not notice. But it's those things that really help you make your app more maintainable and more predictable, not only for the developer, but for the user. \n\n[00:07:26] Because we don't want to see inconsistent states, we don't want to see an error that immediately disappears. Or we don't want to run into a state where we can't get out of such as an error state that requires us to restart the entire application. So using state machines for modeling, which like we looked at at the last exercise, modeling states, events and transitions are going to be really helpful for avoiding these kinds of invalid states, invalid transitions and other things that we'll run into when we don't explicitly model our app logic. \n\n[00:08:04] Then the last one which we're going to be talking about probably at the end of the workshop is declarative side effects. The main principle of this is we want to separate updating our state so that peer application logic from the actual execution of the side effects. A great example of this is the ELM architecture, where with ELM and you have this idea of when you're in a state and you have some sort of action or event, it's not just going to return the next state. \n\n[00:08:38] But it's going to return the next state and also what it calls commands or effects that are supposed to run when that state is executed. And so by having that be declarative, we could both easily test that these side effects are going to occur. And also, we separate the pure logic, so the pure function from the execution of the side effect. \n\n[00:09:05] So it makes it a lot easier to test. We don't actually have to test that, this side effect did something when we ran this function. So let's make sure that it did the right thing. We could just test ahead of time like this effect is going to be called. \n\n[00:09:19] And also, it just makes the behavior more predictable. For example, let's say that we were in a flight search page, and we start searching. We don't just want to go to a flight search results page, we want to go to a flight search results page and kick off the searching process. \n\n[00:09:36] And so that's where declarative side effects really come in handy."
    },
    {
      "number": 10,
      "title": "Finite States",
      "slug": "finite-states",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/finite-states/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: So in this exercise we're going to be keeping those principles in mind through pretty much the entire workshop and of course also this exercise, but also we're going to be doing two things. We're going to be combining states, so really reducing the number of use states that we have. \n\n[00:00:20] And we're also going to be learning about type states and finite states. So, let's talk about the first concept. Let's go to a scratch pad, so finite scratch. Okay, let's say that we have an application for, I don't know, let's say that we're making coffee. So we have const coffeeType, setCoffeeType. \n\n[00:00:50] We have different types and it's already like just giving me a whole bunch of different options. We also have size, and we also might have sugar and milk. The thing is that all of these are actually related. So we're ordering a coffee. We do have multiple use dates here. \n\n[00:01:10] One of the things that I want you to get used to, you don't necessarily need to do this, but honestly, when you have a lot of use dates, it can become a problem, but group related data together. So, instead of all of this, we could just have, let's call this coffee, say coffee. \n\n[00:01:30] And instead we could combine all of this into a single object. So this is going to be the type of coffee, the size, the sugar and milk. And we can all have this in one single object. Now the pattern for updating the state is actually going to be a little bit different. \n\n[00:01:49] So over here, when we're handling the coffee type change, we're no longer just setting the single state variable, instead we're updating the entire object. So that can look like one of two things. It can either look like something where you take that existing object like coffee, and then you pass in the type over here. \n\n[00:02:15] So you're basically taking that entire object and just saying, I want this object with this type updated. Now there actually might be a small problem with this. This coffee is a closed in variable, so we have a closure issue, which sometimes it's not a problem, but other times we might see some unwanted side effects. \n\n[00:02:38] Which is why I actually recommend using the pattern of grabbing the previous value and instead using that. So that's going to use the existing coffee over here and say I want to update the type based on the previous value of it. So that is one way that we could basically combine our entire state. \n\n[00:03:03] So, let's put some default values here, and that's exactly what it looks like. Now, another thing that I really want to demonstrate here and what we're gonna be using in this exercise, is the idea of finite states. So let's say that we have another two and then we are making our coffeeOrder. \n\n[00:03:29] So let's say that we have const coffeeOrder set coffeeOrder. And this is just, yeah, oops, some use state over here we're ordering a cappuccino, and we also want to model actually making this order. So this is probably muscle memory to a lot of React developers. But you're going to start with your constIsLoading, setIsLoading, and then maybe const isSuccess. \n\n[00:04:01] So you have that boolean and then const, oops, const error, setError. And then you're going to actually kick off the, the ordering process, probably in a use effect. So you're gonna have a useEffect over here, and then again this is all muscle memory. You want your coffeeOrder over here, and then it's going to, it's going to do something, it's going to make a fetch request. \n\n[00:04:29] So, let's actually do a demo fetch request over here. So, mock fetch call. So we might do something where like we're fetching that order and then we have all this boilerplate that we have to add. We set success to true, loading to false. And then if we have an error, then we also set loading to false. \n\n[00:04:51] And this just gets problematic because it might seem simple over here, but we're really managing two seemingly unrelated pieces of state that are actually supposed to be related. And we also need to handle canceling. So if not cancelled, then we go ahead with this. So instead of that, I want you to, just based on our previous exercise, think about the different states that we could be in. \n\n[00:05:23] And so this actually makes a pretty simple refactor. Instead of is loading is success and error, we could do const status, and we could have a string enum representing the status. Now we could eliminate basically both of these, and instead we could set status loading. We could eliminate both of these and just set status to success because those are mutually exclusive. \n\n[00:05:55] We never want it to be loading in success at the same time, in reality we're just changing one thing. And then we have an error over here, so we're gonna set the status to error. And so, that's one way that we could really simplify handling multiple boolean states that are really meant to represent one kind of state. \n\n[00:06:21] Now if you want to go above and beyond, there's something called, or there's a pattern called type states. And so with type states, here's a problem that it solves first of all. Let's say that we're trying to render something and we have if status is success. So, let me add another variable here we have const receipt, set receipt. \n\n[00:06:50] And this could either be a string or null. So, I want to show the receipt, but again the receipts. Actually let's do this. Let's make the receipt a total. So, a problem with this is that, and it doesn't matter if you're using finite states or if you're just doing something in your application where you are 100,000% sure that this receipt, when the status is success. \n\n[00:07:16] Or even if you have issuccess, you know that that receipt is going to exist because, let's say that we set the receipt over here. So we're setting the status and we're setting the receipt. You know that that exists. So in Typescript you might add an exclamation mark. It's actually totally fine if you add multiple exclamation marks in some cases. \n\n[00:07:40] I discovered that randomly. But the idea is that you want to, at a type level, ensure that this receipt exists. So, how exactly can we do that? Well, we can use type states. So type, let's see, CoffeeOrder. And we're going to be using in Typescript what's called a discriminated union. \n\n[00:08:05] So, instead of just a plain status string, we're gonna put it inside of this object. So we're gonna say status is idle or loading or success or error. And this is actually a good way to start out. You have the error, and then you have the receipts inside the same object. \n\n[00:08:23] So from there you could actually transform this to a discriminated union by adding this pipe and then saying status success. So now we could actually get rid of this, and we could say that the receipt is definitely defined over here. So we could say that in this case the the receipt is null. \n\n[00:08:48] But when we have success, we definitely have the receipt. And so here's how this looks. Let's actually just put this somewhere else. So let's const CoffeeOrder. And then we have idle. We have no error and no receipts. And I'm actually going to delete this over here. And so instead of this, we could set coffeeOrder to status success with the receipt. \n\n[00:09:20] And here is the really, really cool part about this. This enforces the data in two places, both when you're setting it. So if I get rid of receipts, it's actually going to yell at me and say, you're missing the receipt here, you're saying it's success, but the receipt doesn't exist. \n\n[00:09:40] So it's really forcing us to keep that state consistent. And then over here, I no longer need this or I have to do coffeeOrder.receipt.total. So if I say coffeeOrder.status is success, then I know for a fact that that exists. So if I change this to error, I know that we don't have a receipt here, or at least we can't read the total because it might possibly be null. \n\n[00:10:09] And so that's what type states are very, very useful for. >> Speaker 2: In the first example, when setting the coffee state, you mentioned using previous because splatting coffee had some pitfalls, which by the way, I think this is the answer to the previous chat's question about setting a profile. \n\n[00:10:28] Send the name and profile, this is what they were wondering how to do this. But what are the pitfalls of just spreading coffee versus using the previous statement? >> David Khourshid: You might run into closure problems with that because you might have a stale version of coffee. No one likes stale coffee, especially if you microwave, it tastes terrible. \n\n[00:10:49] But if you have a stale version of a value, then when you set coffee, you might accidentally revert to that previous version or at least different properties of that previous version. And this can show up in many cases, if you put this in a used memo and decide to memoize it excessively. \n\n[00:11:07] Or maybe it's in an event handler that does not change for some reason. Or even in a useEffect, there's just many places where that might come up. And so that's why, honestly, as a best practice in a habit, just try to go based on the previous value inside of that function, because over here you're guaranteed that that value is going to be the latest value value of that state. \n\n[00:11:31] >> Speaker 3: I'm thinking of a scenario where some related states will be updated in one context provider, but a smaller consumer component may only use one part of the data. So will that lead to unnecessary read renders? >> David Khourshid: That's a very good question. So, it definitely depends. And this would be a good use case for useMemo. \n\n[00:11:52] So you could just see if all of those values are the same. But honestly, it's not a big problem in practice. I wouldn't recommend you to just put every single use date inside your component inside of a single use date. Instead, I want you to separate it by concern. \n\n[00:12:11] So for example, this coffee object, this is an object that we could pass around. And so chances are that if we change the size or any part about that coffee, the entire object fundamentally changes and so we might want to let components downstream know about that change. But in practice I haven't seen this to be a problem. \n\n[00:12:37] So, always just double check before you decide to put any optimizations in place. But just know that there do exist some optimizations in react like useMemo, etc., for that. And then Masij asks in CoffeeOrder, did we use generic type as the first variance because the union was not exhaustive? \n\n[00:13:03] So in reality, yeah, you might wanna flesh this out a little bit more. So for example, if we're loading, then we know that we don't have a receipt, we don't have an error, but if there is an error, so we definitely have an error and there's no receipt. \n\n[00:13:23] So then we could just get rid of these and we have our complete type state over here. So this is more around the lines of what it should look like."
    },
    {
      "number": 11,
      "title": "Combining State Exercise",
      "slug": "combining-state-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/combining-state-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Great. So we are going to jump into the next exercise. And so what we're going to be doing is two things. First, we have a flight booking form. We're going to be combining related state variables. And this is just again to practice getting used to combining related state into one single use state. \n\n[00:00:26] And also because there is some loading and error and success states, we also want to remove the Boolean flags and create finite states instead. And you could start by just having a simple status as a string enum, or if you want to again go above and beyond, you can use discriminated unions and use those type states. \n\n[00:00:54] All right, so let's clean this up a little bit with some finite states and combining things. Another thing that I really want to talk about too is the strangler fig pattern. And this is actually going to help us solve this exercise because likely you don't want to just delete code and replace code and then pray that it works. \n\n[00:01:16] Instead, you really want to check side by side if the code that you're replacing the previous code with is going to be the correct result. So we could combine pretty much all of these, like the destination, departure, arrival and passengers together and we could combine it into one. \n\n[00:01:39] Let's call this flight data. And actually it's not going to be that. Let's turn off this. So this is going to be the destination, departure, arrival and passengers. And so this is going to be the default states over here. So we have empty string, empty string, empty string and passengers. \n\n[00:02:08] We'll just default it to 1. And so again, we are going to identify these Boolean variables which are actually mutually exclusive. And we're going to change this and put it into a status. So const. Status, set status. We're going to use dates. And so we could start off with saying that, you know, maybe it's idle. \n\n[00:02:30] We didn't do anything yet. But we could change this to a string string type or what I like to call a string enum. Or at least it functions like when it's not literally a string enum. So idle, submitting error and success. And so what this allows us to do is we could actually just side by side work on a, you know, work on refactoring this while just maintaining the same structure that we have. \n\n[00:03:08] So for example, when we set the destination instead of this, we could just, we could set the flight data to again, we're using previous. So we are going to get the previous data and set the destination to E target value. And so we could do this for the other ones too. \n\n[00:03:33] Just to make sure that everything works. So I'm going to do this for that. And again, this is the exact same thing that we're doing. We're taking the previous data and we're just updating that one field over there and same thing over here. Another quick trick. You see that we're doing parseints over here. \n\n[00:03:58] What we could actually do is E target value as number and that basically does the exact same thing. So then when we have things like issubmitting, we could do one of two things here. We could either keep the same variable or we could have a more explicit like flight data. \n\n[00:04:25] We don't have the status. So we could say status issubmitting or like we learned about in our first exercise, and this is actually a really good way to not change too much code but still do the refactor that you want to do. We could keep that issubmitting and instead we could derive that data. \n\n[00:04:48] So we have our status over here. We could say const isSubmitting is basically if the status is submitting. So these boolean flags become something that's derived rather than something that becomes a source of truth. So again, that first exercise is really showing us how we could improve the way that we model these things. \n\n[00:05:14] So now if I get rid of this, we see a bunch of variables together over here. And so instead of all of that, we could just set the status to submitting and then get rid of the other ones. And then we'll set the selected flights to null. This is also a good indication that if you want to, you could use type states to really combine that into a single cohesive state variable. \n\n[00:05:42] So instead of set success true, we could set the status to success. And then over here we could set the status to an error. So now you're going to see that again, lots of red here. We're no longer using this. So we could do things like derive more data. \n\n[00:06:01] So we could say destination is flightdata.des Station and in fact we could just pull out departure, arrival and passengers from here. And that way we have limited changes to our code, but we can reduce the number of use states that we have. And we could have all related data in a single object. \n\n[00:06:27] So just going through this again, we no longer need things like set iserror true because now we're setting the status to an error. And so same thing over here, iserrorn is success. You could either change that to checking the actual status or you could derive that data. So we could say const iserror is if status is equal to error or const issuccess is equal to if the status is a success and then everything should work the exact same. \n\n[00:07:01] So again, being able to look at your application and understand the different flows that it could be in is really going to help you out here. So in this case we know that this can be considered some sort of an idle state and you might choose a date and then we have this loading state over here which we could visually verify. \n\n[00:07:30] Then we have the state over here where we successfully have data. We could select a flight and we could see that booking summary. And if we wanted to, this can be a different state on its own. That is actually going to be the case when we go into future exercises. \n\n[00:07:48] So yeah, any questions about this exercise and how we refactored everything >> Speaker 2: not directly related to the exercise, but there was a question about your opinion on using arrow functions within a handler, because isn't passing the function directly to the handler better approach? >> David Khourshid: Okay, so yeah, the question was about, for example, handleFlightSelect if you could do it here. \n\n[00:08:21] So it sort of doesn't matter to me. It is dependent on your team though. So some of your team might like to put all of their handlers up in front and I think that that's a very good way to see everything. Just like that principle we talked about where we're separating the framework from the actual logic. \n\n[00:08:40] And so by having the handlers up in here, then you see all of the logic together and then all of the UI below that. So it is pretty nice to do that in terms of arrows or functions, that doesn't matter to me either. But yeah, another thing that some people could do is instead of handle Flight select, they might just set selected flights directly over here. \n\n[00:09:08] And I honestly think that that's fine too. If you find yourself repeating that a lot, that's where a handler might be useful. I think a lot of React developers do go overboard and they try to memoize that by putting it in a use callback. And honestly, if you don't need it, then it doesn't really matter if you do it or not. \n\n[00:09:30] I like to only memoize if I notice that there's a problem. >> Speaker 3: Isn't there some kind of performance overhead associated with UseMemo and Use Callback too? So if you're using it when you don't need to, it can actually make things perform worse. >> David Khourshid: Exactly, yeah. This is something that you learn in computer science. \n\n[00:09:50] I only took a couple of classes, but when you're doing optimizations such as caching, memoization, et cetera. It's not that you're making everything magically faster. You, you're trading performance for memory, so there are trade offs there. And so if you try to use Memo everywhere, then the internal memory used by the React app will, you know, it might balloon, it might slow things down, honestly, like everything's a micro optimization until you actually run into the issues and see that, okay, this is slow, but if I do this, then it's definitely visually faster for the user, especially on a slow connection or low powered computer. \n\n[00:10:32] So yeah, I like to be pragmatic about performance basically only when necessary. >> Speaker 4: I know React19's goal is to release the compiler in its full state and so therefore they're attempting to try and minimize the need for UseMemo and Use Callback. What's your take or opinion on that shift in their paradigm? \n\n[00:10:59] >> David Khourshid: I think that, yeah, the React compiler is great and this is more reason to use idiomatic React patterns and not try to do anything crazy or try to over memoize or do callbacks or things like that. I will say that in larger code bases too. First of all, with React Compiler there is that expectation that you're using React and React hooks as designed. \n\n[00:11:24] However, I have seen in many code bases, and it's sort of inevitable with larger code bases that people will have a long, long dependency array with like five or seven different items inside and they will be missing maybe one or two different variables that should be in there, but they'll be missing them on purpose because if you add those variables in, then the useEffect might run multiple times or the useMemo will unnecessarily call itself again and maybe have a side effect in the useMemo, who knows. \n\n[00:11:55] But the idea is that they will disable the eslint rule for that dependency array because it's one of those it works, don't touch it. And if you complete the dependency array with everything required, then it's going to break. And so there's so much of this in existing React applications and that actually doesn't work well with the React's compiler. \n\n[00:12:17] So that's why I say try to avoid having too many things in dependency arrays or even using hooks that require the use of dependency arrays. It's going to make your life simpler and it's going to make React compiler work a lot better because you're just doing things the most natural way."
    },
    {
      "number": 12,
      "title": "Type State Implementation",
      "slug": "type-state-implementation",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/type-state-implementation/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Okay, yeah, so let's quickly do the type state implementation. So with the type state implementation, what we want to notice is that we have things like when we're setting status to submitting, we're also setting the selected flights to null, or we're setting flight options when it is a success. \n\n[00:00:17] And so these are all clues that we could use a type states to really reduce the number of states that we have to set and the states that we have to manage. So we're going to, let's, you know, we have flight data over here, let's actually add the status inside here as well. \n\n[00:00:39] So this is going to be idle. And so now we could actually define our type states. So we could have type flight data which includes all of this. So we have our destination, departure, arrival and passengers. But we're also going to be adding, with an intersection type, we're going to be adding our different type states that we could be in. \n\n[00:01:03] So just for speed, I'm using Claude. But we have for example, idle submitting, error and success. So we know in success we have our flight options defined and we know that in error we might have an error message over here and that when we're idle, our flight options are actually null. \n\n[00:01:26] And same thing for submitting, our flight options are null. So we don't have those in there. And so this is a pattern that if you have common data, then you might want to use an intersection type for that. So you would have all of your common properties in one object intersecting with your discriminated union at the bottom. \n\n[00:01:50] And so that way like, you know, we have flight options null and you could even. In fact, it is good practice to put everything up front here. So we have flight options and we have an error. So we're representing all the possible values that it could be here, but we're limiting that when we actually deal with each of the type states down here. \n\n[00:02:15] And so now when we have something, for example set status submitting, we can instead set the flight data to have the status be submitting the selected flight be null. And of course the error is going to disappear too. And then we no longer need those variables. So same thing for when we actually have a success. \n\n[00:02:37] We could reduce these two into a single set flight data with the status of success and the flight options that we have. >> James Halliday: Maybe you need to actually type the use state up there for the set flight data. It's just according to the object you pass in right here. \n\n[00:02:57] >> David Khourshid: You're right. Okay, so [LAUGH] we have that typeState, but we didn't actually have our different options over there. Okay so now it works. Thank you, we were just missing the type, that's all, so okay. Wow, that was an embarrassing mistake, but hey, type save the day over there. \n\n[00:03:18] So yeah that's an example of how you could use discriminated unions and type states and also combine related data to reduce the number of use dates and also just keep your data more consistent. Any questions? >> Male Speaker 3: Just James saying typescript can be tricky sometimes is the understatement of the century [LAUGH]. \n\n[00:03:45] >> David Khourshid: It helps you out but it also can cost a lot of time but it's more helpful than it is a burden, so I do appreciate it. >> Male Speaker 3: Then we could have error that even caught the fact that we didn't include error there. >> David Khourshid: Exactly. So that's what I mean about just keeping your data consistent and so if we happen to have flight options here it's going to yell at us and say wait a minute this should not be possible so."
    },
    {
      "number": 13,
      "title": "Managing FormData with useActionState",
      "slug": "managing-formdata-with-useactionstate",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/managing-formdata-with-useactionstate/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Okay, so the next one that I want to talk about is actually, it's a shorter lesson, but it is one of the ways that you could actually simplify basic forms. Because let's be honest, a lot of our application is just a bunch of forms and most of these forms are actually simpler than we realize. \n\n[00:00:22] So I'm going to go to the scratch pad here and just demonstrate to you basically what we could do about forms. So let's say that we have a form and we have, you know, first name, set first name. And just for, just for this example, we're going to only use one first name and then we have a form which handles that first name. \n\n[00:00:50] This is code that you learned when you are first starting off in React. It is probably the most basic and common example of use dates and working with forms, and so the idea is that we would have an on submit over here. And again, this is muscle memory, but you would type event.Prevent defaults, because the form is going to have some sort of default action of reloading the page. \n\n[00:01:17] And you don't want that, which is why we have it over there. And then let's say that our form just consists of the first name and we want to do something with that. We could just console log the first name. But here's the thing, in HTML and the dom, the form actually contains the state itself. \n\n[00:01:39] So really we're duplicating state over here. When you type into an input, and especially if you give it a name, like let's say that we give it a name of first name, that data already exists in the form itself. So let me show you what I mean. If we get rid of this on change and instead we read the form data from the form, then we could really just in a way we could derive that information. \n\n[00:02:08] So we're going to grab the form data using this new form data constructor and using this target, which is the form element. For some reason, even though we're in OnSubmit, TypeScript thinks that it can be any random element. So we have to say no, this is definitely a form elements that we're working with. \n\n[00:02:31] And so what you're going to get is a form data object. And so the FormData object, it has its own API, but it is completely native and supported in all modern browsers. So what we could do is if we want to get the first name, there's formdata get, and then we could get that name, you know, just directly from the form data. \n\n[00:02:53] And so what this allows us to do is really eliminate a number of use dates so we don't have to keep track of each individual field. Instead we could just read from that. Now if you have many fields, then we could actually use. We could use Zod as well. \n\n[00:03:13] So how many of you are familiar with Zod? Okay, or whatever related library you're using. So with Zod we could actually parse, we could create a schema for the form and so we could parse that information from the form. So let's say const form schema equals an object where we have the first name and then we could just add some validation there. \n\n[00:03:46] But Zod also allows us to parse and see that the entries of this form data, which the form data you could use object from entries because it's going to be key value, key value, key value. And then you could create an object from that. So you could parse that using the form schema. \n\n[00:04:07] And if there are errors and this allows you to do form validation as well. So you might have a first name is required thing or something like that. But we could get parsed data firstname if it exists. And we know that that's going to be a string. So that's how you could use Zod as well in combination with form data. \n\n[00:04:36] So why am I showing you this? This is definitely an alternative to using just multiple use dates for your form. But also when you're working with a next JS application, there actually is a hook that really helps you with work natively with forms. There's both a hook and there's a native Next JS server components or Server Action feature that allows you to pass a server action directly into a form and to use that. \n\n[00:05:09] And this will handle all of your forms loading states and the response from submitting the form and everything like that. So the way we could do that, if I get rid of all of this, we're going to grab the use action state hook. So it's gonna be states some submit action. \n\n[00:05:34] So just gonna say, action equals, and this is something that just takes form data. So we're going to use action state, pass that submit action in there and and then also pass in an initial state. And this is just something that it requires. So this initial state we could just have as null and it's also going to give us is pending. \n\n[00:06:02] And so the cool thing about this is that we could pass in that form action directly to the form and then we don't need to maintain the, we don't need to maintain each of the individual variables because it's going to be done via name and then when you press submit, it's just going to go through that form action we're going to get is pending, so we could definitely have a pending state. \n\n[00:06:26] So if is pending, then we could show something like a loader or something like that and then eventually we will have our state. So if we have our state then oops, not that, but we could return the state that we get from the submit action."
    },
    {
      "number": 14,
      "title": "Converting useState to FormData",
      "slug": "converting-usestate-to-formdata",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/converting-usestate-to-formdata/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: For the next exercise, I'm not going to actually have you do this, but we're going to be doing it together. I just want to show you how we could use these native form tools that we have built into the browser and built into Next JS instead of having to manage a lot of use dates with those forms. \n\n[00:00:20] So gonna get rid of that and then we are going to go to see exercise form page. And over here we, we definitely have a bigger form. So we are, we're going to definitely simplify this a lot. At the very least, we do have our combined data over here. \n\n[00:00:46] So we have our travel form data. And just to show you what this looks like in the ui, if we go to form, this is a form for entering travel information and there's a lot of fields in here, which is why I'm showing you this pattern. Because doing this with just use dates, it can be tedious. \n\n[00:01:05] You have to have a use date for first name, last name, birthday, Passport, Origin City, etc. I feel like 2000. Yeah, I feel old because 2000 I think, okay, there's kids that are born in 2000, but it's all grown adults. It's very weird. But anyway, you know, you have your passport number there and the idea behind this is we want to have server side validation and that's what you see coming back over here. \n\n[00:01:36] But in this, in this form you can also submit your travel data and then you could submit another form and then, you know, keep going like that. So our initial implementation, we're using useState a lot over here we have these Boolean flags, issubmitting issuccess. Hopefully you immediately recognize that you can change that for a simple status string enum and same thing over here you could use type states and discriminated unions to combine the status with the data. \n\n[00:02:14] But we're going to be simplifying this even further than that. So again, using the strangler fig pattern that I talked about, we're going to start by saying const state submit action which already exists and I'll show you in a minute and is pending and we're going to be grabbing that from use action state, which is a react hook. \n\n[00:02:36] Again, you have your submit travel data and also you're going to be passing in an initial state. And just to show you what this initial state looks like, we have our, you know, we have all of our information here. Wait a minute. Okay, let me just make sure that we have the right initial state over here. \n\n[00:03:01] So this is Actually going to be coming from somewhere else. Okay, so initial state formstate equals status idle, no errors and data null, and so you'll see how this is used in a minute. But the idea is that all of our inputs should already. I'm going to go ahead and hide this. \n\n[00:03:31] But all of our inputs should already have names. And so that's going to be the thing that really powers using form data is the fact that our inputs and all of our fields have names that are going to be fed into the form data that we derive from it. \n\n[00:03:46] So instead of onsubmit, instead we're going to put action and this action is going to be our form action that we have over here. So just going to the top submit action. And then what I'm going to do here instead of deleting everything first is I'm going to console log the states. \n\n[00:04:11] Just so you see what we're dealing with. So we have the state over here and we are also going to console log is pending over here. All right, so now we're going to, first of all, let's make sure we're running this. All right, so we're in our exercise form. \n\n[00:04:38] I'm going to open up the console over here. We have is pending as false, we have our initial state object. So let's go ahead and enter some details. Again, the state is changing and if we submit this, it is going to hit the even though it's invalid, it's going to hit that server action and we're going to get some data back from the server. \n\n[00:05:06] So we're gonnasee a bunch of errors. We're going to see that the birth date's invalid, the origin city is invalid, et cetera, but it is hitting that server and we also get a status back. So where does this happen? Let's take a look at form and then actions. \n\n[00:05:27] So when we submit travel data, first of all, we're getting this raw data and we're getting it from the form data that it receives. So we could validate the data using Zod, like we talked about, and then we could use that to generate errors. And so if we have errors on specific pieces of data, then we could pass that back. \n\n[00:05:51] However, if everything goes well, we sort of have a mock API over here. But if all goes well, we have the success and we're also returning the data from there. And if we have an error, then we're actually giving back the raw data because we don't want to completely blow away the form states. \n\n[00:06:13] We want them to be able to correct their errors. So in this case we're not managing the status inside of the actual ui, but instead we're managing it on the server side. So we're saying the status is success. And in this case we also have results data. So if we go back here and actually fill everything out, so 2000, not my actual birthday or passport number and I don't know who would ever pick middle, but it's an option in some airlines. \n\n[00:06:47] But once you submit this, it's not happening because we didn't update it in the ui. But you could see over here that we have state of success. We have our data coming back, we have no errors and we can use that in our, in our application. So just like what I, what we did previously, instead of using this issuccess use date, we could derive that. \n\n[00:07:14] So const issuccess equals state status equals success. Same thing here, instead of errors we could say const errors equals state errors, and same thing over here, instead of is submitting, we could say const issubmitting equals if the state dot status is pending. And now we have a bunch of errors, but we could just comment those out because we're actually no longer using this function at all. \n\n[00:07:55] So we're just going to comment that out. So now when we fill out our form again, set the birth date, passport number, origin, city, seat preference. Okay, let's put 2000 now let's debug this together. We could see that we have a status of success, but it is not showing us success. \n\n[00:08:26] It's if we have success data as well. So that is still in the use dates, so we need to derive that too. So const success data equals dates data, so now one more try. David K, >> David Khourshid: It's my actual birthday [LAUGH]. >> David Khourshid: I love sitting in the aisle. \n\n[00:08:54] Okay, now we have our successful travel data and now we could actually get rid of basically a lot of things. We could get rid of all of these use dates and all this unused code and even this like the whole setformdata thing where we basically don't need that anymore, so we could get rid of that. \n\n[00:09:21] And so now all of these can just be uncontrolled components, and so you could see that this really simplifies how we work with simple forms. And then, yeah, we no longer need this handle submit because everything happens inside of that server action. We no longer need this update form field helper. \n\n[00:09:49] So update form field again, where this is going to be just uncontrolled data. So we don't need that either we're actually going to turn on Claude and have it help us out here. Don't need this or this or any of these. So we could get rid of that and get rid of that as well. \n\n[00:10:12] So now you see that we really, really simplified our form. This might not even be necessary if you use the state status directly. But everything is just a lot, you know, it's a lot simpler. And in fact this is pending, this is redundant because we don't need issubmitting. \n\n[00:10:35] We could just, you know, basically have that as is pending. So we have all this issubmitting which we could change to is pending and then be all good. And so now there's a lot of unused things that we could remove and our code just becomes a lot simpler. \n\n[00:10:58] So that is how we could use the use action state hook and use built in server actions to handle forms. And also at a basic level, using form data for basic forms where you don't need anything special with a form, you just need to capture data. >> Male Speaker 2: Is it possible to have immediate blur focus of validity checking for those inputs when they are not controlled? \n\n[00:11:25] >> David Khourshid: That's a good question. So two things. First of all with server actions it's sort of, or you know, form actions as it's called in React it assumes that you're going to basically submit your form all at once, so it's not going to be doing any validation on blur. \n\n[00:11:45] The second thing too is that when you have uncontrolled components and you want to basically keep track of validation errors on Blur, I recommend you use some of the patterns that we learned about earlier. So for example, we could do things like const, let's call these validation errors set validation errors and then we will have a use date for that. \n\n[00:12:12] And this is somewhere where use data is appropriate because this happens not during the client server interaction, but it instead happens only on the client. So what we could do is let's say that, you know, we're, let's just pick one of these fields. So for example, first name. \n\n[00:12:34] First of all, if you can use HTML5 validation then this is something that I strongly recommend you do. So this is for example, if you add required or if you add a pattern over here just to make sure that the data is valid, like this just says it should be more than one character. \n\n[00:12:53] So basically it's like it has to be there and it has to be a valid name, then I would recommend you do that. Otherwise you could just. On Blur you have the event target dot value and so you could say const value equals event target value. And then you could do validation directly in there. \n\n[00:13:18] So you could set the validation errors. For example, if it's less than 3, you have that over there. Just be sure to handle what happens in terms of showing that. So for example, if this is focused, you don't want to necessarily show that error. Or maybe you do, and maybe it goes away once you blur from that again. \n\n[00:13:37] But this is just an example of how you can do validation on blur in an uncontrolled component, because you have that value right there. All right, so we were just talking about form handling with form data and server actions and how we could basically use this for simple forms, forms that don't have that many requirements. \n\n[00:14:00] But there was an excellent question in the chat where it was about managing large forms or form states with a lot of dynamic validity or maybe async validation. Or there's a long time ago I did write a form library called Redux Simple Form. So I do know about like just all of the different potential use cases and edge cases of complex forms. \n\n[00:14:23] You have nested forms, you have dependent fields, async validation, masking, things like that. So forms get very, very complicated, the question was about how would you handle that, or are there resources which talk about complex forms, date management solutions and best practices around that? Yeah, it's true that when you're dealing with complex state management, the usual culprit is actually forms, either complex forms or multi step forms in your application. \n\n[00:14:59] And so the way that we could approach this is first of all, if you have a simple form, try to keep things simple, again, the default is you would probably use date for each of those individual fields. You can apply the previous lessons we talked about and first of all combine those use dates into one use date, just to make things a lot simpler. \n\n[00:15:22] And also when you're sending that data over, you know, for form submission, it's all in one object, so it becomes really easy. Or you can take it to the next level and use form data with Zod to validate that form input. So then you get that, you get all of these form inputs and you get that validation for free just by using form data. \n\n[00:15:43] And it works naturally with server actions for frameworks such as Next js which allow you to natively handle those forms. But of course there's use cases like I talked about with async validation, complex forms, et cetera. We're going to be talking about data normalization later, which simplifies the nested form aspect a lot. \n\n[00:16:06] But when you're dealing with more complex form requirements, I recommend you use a library that already handles this for you. Such as, there's Tanstack form, there's React Hook form and there are similar libraries. What I would not recommend is trying to roll this yourself because again, there's a lot of edge cases and when you roll your own form based abstractions, first of all, you're probably reinventing the wheel. \n\n[00:16:32] Forms are one of the most common things in web applications, so try not to do that. And secondly, when you're working with teammates, it's better to point them at documentation, e.g., TanStack Form or React Hook Form, rather than trying to maintain your own documentation for your own abstraction that you built. \n\n[00:16:53] The second thing too is things become a lot less complicated when you go based on the first principle that we talked about, which is events are the actual source of truth. So thinking about, for example, async validation, it sounds really complex and really scary. But when you think of it as I put an input in there and then something goes off to a server and comes back with data saying whether it's valid or not. \n\n[00:17:19] Now we have, going back to our diagrams, you could think of it as a sequence diagram. We have our form and we have some sort of validation API that we're hitting. And we're also thinking about events too. So we have an event where we're updating the state and then we have an events coming back, so then you could use patterns like useReducer to actually handle that async validation if it's not handled already in those form libraries that I talked about. \n\n[00:17:49] So again, data normalization and also treating everything as an event and handling the events rather than treating async validation as something special, that's gonna really help you a lot with complex forms."
    },
    {
      "number": 15,
      "title": "useReducer for Complex State Logic",
      "slug": "usereducer-for-complex-state-logic",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/usereducer-for-complex-state-logic/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Okay, so let's get to the next section. And this is an image that sort of introduces what the next section is going to be about. And it's of course, useReducer. And useReducer is actually a very useful hook when you need it. I know that a lot of you might have come from Redux or come from similar areas where you've either used a Redux reducer or you've used used Reducer, and it just feels like a lot of boilerplates. \n\n[00:00:37] But the fact is, when you have complex app logic requirements, using a reducer is going to be a lot better than trying to manage multiple use dates, use effects, and even use context. And, and the reason is because useReducer, it's in the name, it literally reduces all of that data and states down into a single function, which you could independently test. \n\n[00:01:03] So again, for complex logic, useReducer is great for simple states, you could continue to use states and things like that. So let's go to the reducer readme just to talk about it a little bit. What we're going to be doing in this exercise is we're going to be combining two things. \n\n[00:01:30] We're going to be combining React Context and UseReducer. Because one of the other great things about UseReducer, this is all because you're able to centralize that logic is, is that you could share that between multiple components and sort of make your own Redux, you could make your own global source of truth where you could read the state and also dispatch events or actions to update that state as well. \n\n[00:01:59] And so this allows you to avoid doing multi level prop drilling or to have this parent component that has a use date, potentially just causing a lot of re renders. And so instead of this, which again, I've seen in so many applications where we're just passing props down through many levels. \n\n[00:02:20] We could instead use context and use a reducer with context to pass the state and the dispatch function down to whatever component needs it. So we're going to be doing that and we're also going to be combining another thing that we talked about, which is finite states. So we're going to be working on a booking flow, or actually it's a flight picker sort of flow, where the first thing we're going to be doing, like we did in previous exercises, is we're going to be simplifying all of these Boolean state values into either a discriminated union or a single object, depending on how much type safety you want. \n\n[00:03:06] And Then we're going to be using the useReducer hook for managing these complex state requirements and we're going to be putting it into context so that we could share that. So just to give you an idea of the motivation, I actually have a demo page over here. Actually. \n\n[00:03:27] No, I don't. I thought I did. Let's find it. Yeah, there we go. Okay, let me see if this is actually in the right place. So we are going to be inside the reducer exercise and let me just move this over. I can't. Okay, that's fine. So I'm gonna copy this, do it the manual way. \n\n[00:03:51] We're gonna make a demo/page.tsx, just to show you a very, very simplified version of what we're going to be doing. So let's say that you have a multi step form. Now in this case there's only two or three steps, but still it counts. You could scale this up to be however many steps. \n\n[00:04:17] Reducer demo. Okay, so it's very simple. Just we have one page for searching for stuff and then we have a loading screen and then we have our results screen. And it looks ugly on purpose right now. But the idea, and first let's talk about the flow. What's going to happen is that you're going to be able to search for stuff. \n\n[00:04:42] So presumably you have a form where you could put in search inputs, you press search and then a loading screen shows up and then after a while you, you get the results. So now you're going to be on the results screen and then you can also go back so you could search for stuff again. \n\n[00:04:59] So it's a very simplified flow, and in fact let's just go ahead over here and map this out just so you could see what kind of flow we're going to be doing. One minute we're going to be creating a new machine and so first we're going to be in this search form and then when we start to search, not really the most appropriately named so call this search form. \n\n[00:05:37] Then we're going to be in some sort of loading screen and then once we get the results, then we have a results page over here. And so in the results page we could actually go back to the search form. And so again I'm demonstrating how useful it is to think in terms of, you know, just diagramming things and modeling your app logic, because even looking at this, we're not gonna build this in this quick demo, but I could see that we're missing Something like error. \n\n[00:06:09] And so we have a failed to fetch results screen. And then even if we add that, I can see that we have another issue in that you can't really retry from here. So we might want something to retry or we might want to do a new search from here. \n\n[00:06:32] So that's just an idea of the kind of flow. We're going to only be working with this small flow over here. And that's the demo that we're going to be working from. This is where a reducer becomes really handy, not just because we have more complex app logic requirements, but also because we want to be able to share the state and a way to dispatch events to change the state with each of those three components. \n\n[00:07:01] So the way we're going to do this is by first making a reducer. And so it's going to look like this function, we'll just call this flow reducer. And we're gonna have a state and an action and we'll fill the types in later. But typically when you create a reducer, you switch based on the types first. \n\n[00:07:22] In previous courses where I talked about XState and building your own state machine, you would switch on the state first and that's a more maintainable pattern. But for this simple example, we're just going to switch on the different action types first. So when we search, you know, we're going to be in a loading state and then once we get results then we're going to be in a result state. \n\n[00:07:47] And then once we go back, we go back to the search states. So now let's add our types. So we are going to have a flow state and this for now it's just going to be, you know, it's one of these three statuses, search, loading or results. And we're also going to have results maybe so any. \n\n[00:08:15] Or we might not have results at all. And then we could just add this over here and then we're going to have some actions that we could do that help us transition between the states. So type flow, action, we have search, let's call this receipt results just to disambiguate. \n\n[00:08:40] And then so we have oops, we have type received results and presumably we'll have some results here too. And we'll, we'll just make this a string and we also have the back action. See, this assumes that we're in the result state. So that's why you might want to add something like if state is search, you can't really go back from there. \n\n[00:09:12] So this assumes that state is results or maybe it's loading and you could still go back. Remains to be seen. So this is our reducer and we're going to add the flow action over there and then we're going to add that reducer. So const state dispatch, you pass in the reducer over here and then you put in the initial state. \n\n[00:09:41] Now we're going to have an issue where it's like the types of status are incompatible. So let's see how we could fix that. We have flow state. We should specifically say that it is going to return the flow state. So now everything is as expected. Okay, so in our different views here, we have a button for searching, we have a button for going back from the results view and the loading view, which doesn't really concern itself too much with any of the states because we're going to. \n\n[00:10:17] It's just an intermediate state that doesn't really show any results or anything, but it could. So how do we actually pass in a way to get our dispatch in here and get the results in the result view? Well, this is where we could use React's context. So I'm gonna say const flow context equals create context. \n\n[00:10:42] And since we want to share both the state and a way to dispatch it, I'm just going to put it in an object. So this is going to be state, which is the flow state and dispatch. Now in some React documentation they do actually have special types for the dispatch function, but I'm not going to use that. \n\n[00:11:03] I like keeping things simple. So we're going to say action, flow, action and that's going to be void because this is a function that shouldn't really do anything. I'm going to grab this import from React and then this is always a bit strange, like this is why cursor helps, but typically I would do null as any. \n\n[00:11:24] The idea is that if you omit the context, then it uses this as the default context. But the idea is you always want to have a provider anyway, so this is unnecessary. But just to make React happy, we're going to either put something simple in here or we could do, I don't know, null as unknown as whatever that type is. \n\n[00:11:49] That's just one of the weird parts about React. But yeah, there you go. Okay, so we have our flow context. So now when we go to the app, we could actually have a provider in which we give the state and the dispatch function. And now this is going to be available to any component that uses that context."
    },
    {
      "number": 16,
      "title": "State Flow with use(), Stores & Effects",
      "slug": "state-flow-with-use-stores-effects",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/state-flow-with-use-stores-effects/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Hopefully if you learn anything new and Cursor hasn't learned this yet, but let's say that we want to grab dispatch from the context. You actually don't need to use context, you could just use. We have a simple hook called use and then you could pass the context directly in there. \n\n[00:00:18] This is one of those small patterns that's definitely going to be the modern way forward for React because not only with context or with some cached state, there's a lot of plans for use. But another thing that's coming up is the ability to use a store. Again, that's in the future for react, but it's a pattern that I want you to get used to. \n\n[00:00:43] You don't need to use context, you could just use use. Awkward to say that, but you get the idea. So now on click. We could actually dispatch that search. So this is going to start the search. The state is going to transition to a loading state in which we show this loading view and then we will see this results view. \n\n[00:01:07] And then we also need dispatch over here. So we're going to grab that from the context as well. And then we're going to just have the ability to go back. But we also need to grab the states here too. And here's where it gets a little bit interesting because we have state results map. \n\n[00:01:31] And so here's the first thing we know, or at least we expect reasonably that results should exist. But it says here that it might be undefined. So this is where, you know, we might want to use type states. And so what we could do is say if the status is results, then the results are definitely defined. \n\n[00:01:56] So I'll just leave that over there. And so we could split this up even further. We could say that, you know, we have a loading status and then we have a search status over here. And just like we did before, we could combine this so that we have our common properties such as results stringer undefined and then we have our discriminated union. \n\n[00:02:28] So you see over here with our received results we already get a type warning because it's like, hey, wait a minute, you're going to the results page, but you're not actually adding any results. Again, this is one of the great benefits of using these discriminated unions, AKA type states, is that it will tell you, hey, you forgot to do something that adds the results to the state. \n\n[00:02:54] So now we could add that. And this is just going to be action results. So now we could go back up here to our results view and potentially get rid of that. But it's still erroring out. And the reason it's doing that is because it assumes that this is any one of the three possible states that we could be in. \n\n[00:03:18] So what we could do is we could say if there are no results, we could return null and hopefully we never get here. But you could also just show some sort of error. This is something that I don't expect users to really do anything, but you could just say error, something went wrong, and then maybe you'll have a back button or something again. \n\n[00:03:45] This is one of those impossible states that we should never be able to get to. Okay, so we have our state, we have our dispatch, we're putting them in a FlowContext provider, and there's one more missing thing actually getting the results. If we go back to this state machine over here, State machines have this concept of actions. \n\n[00:04:13] One of the actions that we could do is an entry action for the results. And so we could say, sorry, it would be over here. So we could actually add an action and we could say in this state, we should load the results. So this is what I mean by a declarative effect. \n\n[00:04:34] We're declaring that in this date, whenever we enter this date, this is where we should load the results. So without getting into X data or state machines, let's see how we could translate that to this application. This, this would be a good use case for useEffect. Essentially, we're saying that when we're in the. \n\n[00:04:56] Not the search page, but the loading page, we should be fetching those results. So we could, let's just do await new Promise a timeout. So we're just doing a. Or actually [LAUGH] It's another weird thing about React. But we do need to. It's a little bit tricky to use async await inside of a use effect. \n\n[00:05:24] So we'll either do this or you could just put another function inside there. It gets pretty awkward. Honestly, my favorite thing to do is use Promise then because we've been doing that for years and that's the most natural pattern inside of user effect. Anyway, the idea is that we are going to dispatch the results result one and result two. \n\n[00:05:46] And the thing that I really like about this is it's based on the state. So if the status is loading, we know we have to do that effect. So we're not, you know, we're not going based on a Boolean variable or even multiple different states, you know, states or variables. \n\n[00:06:06] Instead we're just going based on this single state status. To actually start this now of course we need to do proper cleanup, and this is where AI coding assistance can help. But now let's see if this actually works. So going back to our travel flow, if we reload, there's one thing that we forgot to do. \n\n[00:06:33] We forgot to actually conditionally show each of these components. So the way we could do that, and this is another reason why I like using these finite states, is that this becomes very, very clear. We have if state status is search, show the search view. If it's loading, show the loading view. \n\n[00:06:53] If it's results, show the results view. The other way that this is typically seen in React apps is you have a long list of conditionals like if is loading and results length is 0 or whatever. So basically you're going based on implicit states rather than these explicit states. \n\n[00:07:17] And so now that we have this, let's reload. It says search for stuff, click search, it's loading, and eventually we get the results. So we could go back and then we could search for stuff again. Now there's one more thing that we could do. This is all contained within the page, but we could clean this up a little bit again to make the code a little more understandable. \n\n[00:07:42] What we could do is we could create a, let's call it flow provider. And of course it's going to take children, which is the react node. And so we could move all of this logic inside of our flow provider. So we have it up here and then, so then we have our flow provider here and down here, quick. \n\n[00:08:15] >> Speaker 2: Also, the state status would be for results would be results received right down below, unlike 143. >> David Khourshid: Let's see what we have here. I think it's just results. So the action is called receipt results. And then we show results. Not the best name, but yeah. Okay, so now we have this issue over here where because all this is contained within the components. \n\n[00:08:48] Now we don't have the state directly, but the easy way to solve this is we could have another component called function flow content. And from there we could use that flow context. And then we could just put all of this inside of there. And then we have our flow content. \n\n[00:09:08] So this looks nice and clean. So does this. And we have everything encapsulated inside of this flow provider. And so now we see that everything still works. So you basically just made your own redux. Okay, I see in the chat Sandeep asks, does using use context? I mean, it's use now, but same thing, use context. \n\n[00:09:35] Does it have any performance implications? The short answer is yes, it does. What's going to happen is that with use context or with using the context whenever the state updates, pretty much everything under there is going to rerender, unfortunately, and this might not be a big problem if you have state that infrequently re-renders. \n\n[00:10:02] So context is essentially the built in React tool that lets you share this dates and share a way to update the state with other components. At least at the moment there is not really another I mean there might be, we'll talk about that in a future lesson, but not really a built in way of doing what Redux or Zustand etc do those libraries really help you narrow down the state, or at least the part of the state that each component expects so that you're not unnecessarily re rendering. \n\n[00:10:37] But again, for basic apps or apps where the state doesn't change too much, this is more than sufficient. It's not really going to cause many performance issues, but it is something to definitely be aware of because it definitely can happen. Like for example, if you have a timer running in there and you have this reducer that changes every single second, yeah, that's going to cause a few issues. \n\n[00:11:03] Or if you have something that's keeping track of the mouse position or any sort of fast paced subscription, then yeah, that's going to be an issue. Lucas also asks in the chat, how would you organize these state machines like a generic step state machine or a state machine specific for booking flights? \n\n[00:11:22] My advice, at least in my experience, is to be pragmatic first. So don't try to go a level of abstraction beyond what you're working in just yet. Always do the manual thing so you have a state machine specific for booking flights. It might be just a very simple step by step sort of multi step flow, but don't try to abstract that out into some generic stepped state machine just yet."
    },
    {
      "number": 17,
      "title": "Context and State Machine Exercise",
      "slug": "context-and-state-machine-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/context-and-state-machine-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: So let's get to the exercise. We're going to be working in exercise-reducer > page.tsx. And you can see that there's a lot of things going on here. This is basically just a beefed up version of the demo that we just saw. There's a lot of confusion over here, a lot of state happening over here. \n\n[00:00:23] We have our typical submit with IsSubmitting, IsError, setSearchParams, etc. And so things get pretty complicated over here. We also have two components, or two and a half if you count this random is error over here. And we're passing in issubmitting on submit where it's just giving back the information. \n\n[00:00:47] And we're also passing the flight options and things like that to the search results, and we're all basing that on some random boolean value. So we have a pretty inefficient way of managing states and sharing that states between multiple components. And again, in your applications, you might think that this is fine. \n\n[00:01:10] You might say, hey, everything works. But even looking at this simple example, it is a bit confusing to see where all the states come together and also how updates are done. There's a lot of prop communication happening. So things are just really confusing. And furthermore, I don't think it even works fully. \n\n[00:01:31] So if I go to exercise on the actual UI, I type in the destination, whatever, Timbuktu, set my dates and go search for flights, sure, this will work. It will show flights, I'm able to select the flights. But once I go back to search, that information disappears. And as a user, I'm pretty frustrated about that. \n\n[00:01:57] But if we have some sort of centralized state management, then that information doesn't have to disappear. We could actually control what that data is so that we could show it on the page when we get to it again. So we're going to be doing a bunch of things in here. \n\n[00:02:13] We're going to be converting this to using useReducer and we're going to be sharing that reducer with those two components. >> David Khourshid: All right, so we're going to be refactoring this multi-step form into using useReducer. Now instead of just showing you, okay, let's delete all of this code, and then I'm going to show you the answer and we're going to replace that code all at once. \n\n[00:02:46] I really want to emphasize the technique that I've been showing you before, where you want to be working on the refactor side by side with the actual code. And this is to make sure that all of the behavior and all of the logic is exactly the same when you're dealing with refactors, without doing anything destructive. \n\n[00:03:06] And this is especially important if you don't have these end to end, or unit tests, or just enough coverage in your application. So again, we're going to be doing this side by side. And the first step, like we learned about in previous lessons, is modeling what we want our state to look like. \n\n[00:03:25] So that's why we're going to start with the booking states. And just based on all of our Boolean variables, we have a status of, we start with idle where we haven't searched yet. And then we're searching and then, eventually, we get results. We could also have an error. \n\n[00:03:49] There's a state for that. We also have flight options which we want to maintain in this state as well. And we have our search parameters that we want to show. So we'll fill that out. So we have our destination, departure, arrival passengers is one way. And again, this stuff comes from what we already have on the page there. \n\n[00:04:12] We just want to centralize it into one state that can be represented in the reducer. And let's get our initial state too. So const initial, let's call it BookingState, which is going to be a BookingState. Status, we're going to start with the idle state. And there's no flightOptions, so we'll put that as null. \n\n[00:04:36] And also the search params are also going to be null. So we will just have that as null. And then the second thing we have to think about is the actions, so basically, what can happen in each state. So we could have, for example, let's do union over here. \n\n[00:05:01] We could first submit, and this payload is going to be everything in those search params. So this is submitting for the search parameters, so that we could start the search. And eventually, hopefully, we'll get results. And so the results are going to include flight options. And we could also go back, so type back. \n\n[00:05:26] And as always, there is a possibility for an error, we're going to have type error, too. And now it's time to actually build out the reducer. So the reducer, we have the state, and it's going to return the BookingState. And then we're going to be switching on our actions for now. \n\n[00:05:48] So first of all, when we submit, we want to transition to the searching state. So this is where we show the loading data. And we're also going to be saving the payload of that action, which is the destination, departure, arrival, etc. Now we are, hopefully, going to eventually get results. \n\n[00:06:12] And so that's going to allow us to change the states too, and change the flight options to whatever we get from those results. Now, right now, we're not using type states, but this is something that you could refactor on top of what you have once you have this working. \n\n[00:06:32] Case back, we're going to go back to that in a minute. But let's just handle if we have an error, then we have an error status. And by default, if we have some sort of unrecognized action, we return the state. Now case back, this is interesting because it really depends on where you're coming from, which we're actually going to see in the next exercise. \n\n[00:06:58] But only if the status is results, do we actually want to go back to the idle state. Otherwise, we return the state. So if you have a back button that is just present on every single screen, but you don't want it to do the exact same thing or go back to the same page on every screen, then you do have to basically tell it where to go based on the state.status. \n\n[00:07:29] And so that's why, especially in my XState courses, we talk about going based on the states first, rather than on the actual events or actions. But in this case, it's simple enough. We could just check, is the state results? Yes, let's go to idle from the result state when the user presses the back button. \n\n[00:07:52] Okay, so now it's time to actually use these. And we're going to go back to the app over here, and this is the main one. We're going to go over here. And then we're going to use that reducer and we have state and dispatch. And so now just like I was talking about with the Strangler Fig pattern, you're going to be doing things side by side. \n\n[00:08:20] So for example, when you handle submit, you want to dispatch. And you're going to have type submit, and the formData as payload. You're going to keep everything else the same, at least for now, because again, you're working side by side with the existing code. So we're going to, for example, over here, once we have those mockFlights as a result, we're going to dispatch that. \n\n[00:08:44] And then same thing here, we'll dispatch an error, when there's an error. And we don't actually need this finally block. And from here, we could console.log the state. So, console.log the state. And this just allows us to see, are we on the right track? Is the state as we expect it to be? \n\n[00:09:11] But we do need to share all of that contents too. So we know that, just to make this easier, we're going to have to make a different component. So I think I called that, what did I call that? Booking content, so we are going to create that context. \n\n[00:09:32] So const BookingContext, we create the context which includes the state and a way to dispatch that action. And then we are going to use that context in our components, but we need to provide it first. So we will make a function BookingProvider with the children, have the state and the dispatch in there. \n\n[00:09:55] And then, pass that in so that the children can use it. And so now that way, inside the Page, we could wrap everything inside that BookingProvider. So BookingProvider over here, and then we could start to use all of this stuff. So even without changing anything here just yet, again, we're making minimal changes. \n\n[00:10:20] We could grab, oops, not over there. But we could grab state, dispatch, and we could use that existing BookingContext in there. And so instead of onSubmit over here, we could just dispatch, submit, pass it in the payload. And then, yeah, forgot that one. And just do things side by side. \n\n[00:10:49] So over here, we're keeping track of the internal state. This, hopefully, is something you recognize from earlier exercises where it's like, hey, first of all, all of this data is related. So we could, potentially, put it in a single object just to clean things up a bit. But also, we could just read that from the form data because this is just a simple form. \n\n[00:11:12] And so that's an exercise left to you, but this is something that you could definitely do. So now when we try this, even though we're not quite finished yet, if I try this out, I could see that once we search flights, okay, we're logging that the status is searching. \n\n[00:11:33] And now we see that the status is results. And we also have our flight options over here, so we know that our reducer logic is working. And so from there, we could go and start just making sure that everything works side by side, and then start to remove the old use dates and the old logic and replace it with the centralized reducer pattern. \n\n[00:12:00] Yes? >> Male Student 1: Why wasn't the selected flight included in the booking state? >> David Khourshid: You know what, that's also an exercise left to the reader. You could definitely include the selected flight in the booking state. In this case, it was just omitted. But if the selected flight is relevant, which in a realistic app, it is. \n\n[00:12:26] If it is relevant to the overall global states that the useReducer represents, then it should be in there, and it doesn't need to be in the component itself. So that's a very good point. We could definitely put selectedFlight over here. But again, remembering a previous pattern, we should use an id, not the actual selected flight, because we don't want to duplicate that state. \n\n[00:12:57] So yeah, you could definitely do that. And then we could add an action to select the flights, and pass it in a string. And then it's asking for other stuff over here, yeah."
    },
    {
      "number": 18,
      "title": "Step-Based Approach",
      "slug": "step-based-approach",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/step-based-approach/",
      "section": "",
      "transcript": "[00:00:00] >> Learner 1: I've often used the pattern of steps, like the step pattern, to do something similar where I have step one, step two, step three. And I would say the solution that we ended up using was not nearly as elegant to do those step by step processes, but it made use of, I think material has like a stepper function, right. \n\n[00:00:31] And so trying to incorporate some of that, I feel like this would have been a better approach versus what we ended up doing. >> David Khourshid: Yeah, so that's actually a, that's a really good thing to call out. So I'm actually going to make a mini, mini demo or just like some demo code. \n\n[00:00:55] Wait, we already have something here. But actually this is still a good point. So let's say that we have something that's multi step. In fact, let's add another view here. So let's just do function confirm view. And so this is something where basically you can confirm your selection or something like that. \n\n[00:01:21] In fact, we could just unclick dispatch select flights and we have to add that real quick. Let's do that over here. So type select flight and then flight ID string and then we're just going to add that to the states too. So we have our flow states. So we have our selected flight stringer null and then we could also go to the confirmed states with the selected flight definitely selected thanks to that. \n\n[00:02:00] So a lot of times, and I'm not going to fully code this out, but we might do something where, like you said, we might have steps where it's, let's say const steps equals. We might first have search and then loading. If you want to put that in steps sometimes like actually it doesn't really make sense to do that, but it does go to show you why, you know, there's limitations to this approach anyway. \n\n[00:02:28] And then results and then confirm. So what's cool about this is it represents a very simple flow where it's like, okay, the steps are clear, we have step one, step two and step three. In fact, I'm gonna bring this out here to show you. And so we would have something like. \n\n[00:02:49] Thanks cursor. We would have something like the current step is whatever the current step ID is. Again, we could use what we've learned and say step index set step index equals useState0 grab that from react and then we could derive the current step from that. So const currenStep = steps index. \n\n[00:03:18] The problem with this though is you basically only have one possible thing you could do, which is go to the next one. So we could say function next step and Then we set the step index to the index +1. You do have to check like am I going to go beyond that array or something like that. \n\n[00:03:37] And if you do want to get fancy, you have previous step two where you could set the step index to the previous one. So there's a couple of issues with this approach. First of all it's very linear. It assumes that you're going 1, 2, 3 or if you want to do a doubly linked list you would go 3, 2, 1. \n\n[00:03:58] So you could sort of go backwards. But there might be some steps where for example incomplete you might not want to go back. So now you have to add special logic where it's like if step index is not equal to three in this case, then return because you don't really want to go back from complete but then that's disconnected from the actual logic. \n\n[00:04:23] So what I like to do instead is make this just a little bit more explicit. And this comes from my experience working with state machines and multi step forms where steps can branch out, steps can loop back, etc., and that is to make a directed graph. So instead of this steps we could have a step graph by the way, no libraries needed here. \n\n[00:04:49] You could do this just with normal JavaScript. And so we could say, in fact we could keep it super simple. We could say that we have search and then on next we go loading same thing here, result next confirm confirm next complete and then complete. We don't have anything from there but on the loading we could go to search or we could go from results to see this is another instance of let's say we have this. \n\n[00:05:22] We wouldn't want to go back to the loading screen. So from here we would go back to search and then we could go back to results from the confirm screen. So now we have this graph representation and then our logic actually in my opinion becomes a lot simpler. \n\n[00:05:43] So next step we have, instead of this current step we would have a const current step set current step equals useState search and then the next step is going to be whatever the current step is next if it exists and if it doesn't exist, just stay with the current step. \n\n[00:06:11] So typescript's yelling at me, it's totally fine, this is still correct. And then the previous step we would just go based on what the previous one is. So just to illustrate that this graph isn't exactly, you know, it's not linear. Even something as simple as this, I'm going to take this and ask make a state diagram of this. \n\n[00:06:38] It's probably Going to use Mermaid. But that's cool. We could visualize Mermaid. It's thinking for a bit or it just does it via. Wow, >> Learners: [LAUGH] This is cool. >> Learner 2: Excellent. >> David Khourshid: Yeah, okay, so you can see it's not entirely linear or pretty, but mostly not linear. So we have this happy path flow here. \n\n[00:07:04] We also see that we could go back from the results. I'm assuming that it's meant to go back here to search and same thing with confirm which it's supposed to go back here to the results might be a formatting thing. Let's ask it to do it as Mermaid and maybe we'll have a better visualization of it. \n\n[00:07:27] So what we're going to receive is probably something better. So let's copy this and go to see Mermaid.live. Paste it in here. Okay, this is better. So we have search loading. We could go back from here. Results. Once we receive the results back, this is one instance where we're not going back to loading, we're actually going back to search. \n\n[00:07:57] And then we have this back and forth loop here. You could go next to confirm and back to results or you could go to complete where there is no back. So this goes to show you that even simple flows are not always linear. An array of steps, I've done that before too, plenty of times. \n\n[00:08:16] But it just doesn't scale once things get a little bit more complicated. >> Learner 1: Yeah, absolutely. Yeah, because we ran into situations too where some steps were optional. >> David Khourshid: Yeah, optional steps. That's a big one. >> Learner 1: Yes. >> David Khourshid: Yeah. >> Learner 1: And so then trying to create something that would essentially from a basic like quick glance looks linear is just totally broken. \n\n[00:08:44] Once you attempt to put too many, what would you say conditionals in it. Because we did exactly the. If you're on step three and you're clicking to the next one and then all of a sudden you need to exit out. We've had to do conditionals within the stepping. \n\n[00:09:04] So I appreciate that you took the time to at least show how you can graph it versus having just a standard array of keeping all your steps together. >> David Khourshid: Yeah, absolutely. And if you want to see a visual, not a visual like this, but like a way of how code transforms from that step based approach to more of a grasp based approach. \n\n[00:09:24] I kid you not, but go to. This is newly released. Go to Jules.Google. And it's sort of my fault that they did this because I made this. Think about it on Twitter. But they basically have this. Don't know if you could see it that well. It says change user onboarding to use a state machine for steps. \n\n[00:09:42] So it started with that array based step thing. And so it's refactoring it to use that basic state machine set up that, that I showed you. And so you see we have the previous logic where next step is based on the index in the array and it's showing that a potentially better way to do that, that scales once you have more complex flows is to instead do it just by doing an object lookup. \n\n[00:10:12] So you could see how it changes it here. And in my opinion the logic becomes a lot simpler once you do it that way. That was a little bit painful and it was only two or three steps. So you could just imagine how like with bigger applications it definitely gets messier when you have bigger flows and more complex flows. \n\n[00:10:36] And that's exactly what we have when we go to the, when we go to the libraries. So libraries exercise. So let me just pull this up. Library, >> Learner 1: One last comment on- >> David Khourshid: Yeah, absolutely. >> Learner 1: The page before we move on. Also too, I noticed that we're still utilizing the on submit within the booking form and we could swap out to using the action. \n\n[00:11:03] >> David Khourshid: Exactly, yeah. >> Learner 1: So that we could even reduce the code down substantially more. >> David Khourshid: Yeah, to be honest, that exercise encompasses a lot of things. I think there's even something there where you can use derived state instead of, you know, the use effect that's going on there. \n\n[00:11:19] But yeah, there's a lot of things in that where I'm glad that you're recognizing the pattern so that you could see, hey, I could refactor this, I could simplify this or potentially prevent bugs in this part of the code."
    },
    {
      "number": 19,
      "title": "Store vs Atomic Libraries",
      "slug": "store-vs-atomic-libraries",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/store-vs-atomic-libraries/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: One big thing that comes up with state management in React is when do I actually use a third party state management library? And the short answer is that you should use it when the built in patterns that React has doesn't really scale. And remember I talked about in the very beginning, that scale isn't just about the number of lines of code or the number of features you have, but it is about how maintainable and sustainable is this code base when the application grows. \n\n[00:00:31] And so when things get hairy and all spaghetti y then you have to question like is what I'm doing with React enough, because when you look at other frameworks and libraries such as Svelte or Solid, they have different state management approaches which avoid a lot of the complexity, the accidental complexity that React introduces just because with state management React is a lot more limited, believe it or not. \n\n[00:01:02] Like this might be controversial, but you can't rely just on React's built in hooks all the time for all use cases of state. Which is why libraries like Redux became so popular. And now there's other libraries like Zustan and Jotai and XState and things like that which people have had to use to sort of smooth over React's incomplete handling of states. \n\n[00:01:29] And so places that we see this are like when you're over relying on context. So if you have multiple providers or if you have just providers everywhere and it could really be condensed like we heard about earlier, the prop drilling we saw earlier and also of course scattered state logic where there is no central place for specific domains in your app where you could see here's the state, here's how it updates and here's the different actions or events that can change that state. \n\n[00:02:01] So that's why third party state management libraries exist and that's why you should consider using them when it's rights to I'm not saying that you should replace all of your state management with these libraries, but it is very useful to understand when to use them and how to use them. \n\n[00:02:22] So in here I outlined just a few ways where it gets really messy. With React states of course we saw prop drilling. There's also state synchronization issues, especially when you have multiple components needing to read the same state and you realize that and you're like well I could either prop drill or move it up to the parents and then do some more prop drilling or use context and suffer the re rendering issue which leads to the context performance problems. \n\n[00:02:55] Because with context, context was meant for states that wasn't like, that isn't going to frequently change. And so that's why the typical example of context is themes, like a theme or just a user preference or something very simple like that that needs to propagate down to all the components, but is not going to change that often. \n\n[00:03:19] So that leaves us in an odd spot where we have state that might change a lot, but context is going to just cause a lot of re renders. And of course, like I talked about, state logic is scattered everywhere, especially when you're using hooks, even even when you're using context, unless you're using useReducer, which it has its own problems with boilerplate. \n\n[00:03:43] It gets really messy. And so that's why there's two types of third party state management libraries. There's the store based approach and the atomic or the signal based approach. And both of these are actually useful. It doesn't need to be an either or. So a store based solution uses a centralized approach. \n\n[00:04:05] You could think of a store as basically a reducer container. So you have some states and then you have actions or events, depending on what they call them, that can operate on the state and cause that state to transition to a new state. I really like using a store based solution because this is what I call indirect state management. \n\n[00:04:29] And what that means is you are not directly mutating or updating the state, even if it is immutable. You're not just saying I'm going to change the state whenever I want, however I want, because that's very problematic. And you might have some centralized app logic where the state needs to be in a consistent way. \n\n[00:04:51] You don't want impossible states, you want to manage things like, for example, a number must have a max value. Or when I'm in the state of results, I need to show the results and I need to be sure that they exist, et cetera. And then there's atomic solutions. \n\n[00:05:08] So in atom, it's not really well defined atoms and signals, but you could think of them as pieces of data that can change from pretty much anywhere. And so they don't have the restrictions of store based solutions. You can literally just update an atom and just subscribe to its value, so that's where there's libraries like Jotai, Recoil and xdatestore, which I'm going to talk about soon, that do make use of these atoms. \n\n[00:05:42] And the other cool thing about atoms is that they're reactive. So you could combine two different atoms and when one of them updates, it's going to combine the value of those atoms and update them. So it handles automatic subscriptions and things like that. Again, there's pretty much two different approaches. \n\n[00:06:00] You should have stores when you have complex logic requirements. When you don't want a piece of state or a piece of data to just change from anywhere, then use a store, because it's going to give you a much more controlled way of managing that state. And you can choose atoms if you want. \n\n[00:06:19] If you have just state where it's like, I know this can change from anywhere, I really don't care. It's just somewhere where it might change externally, or it's something that we don't necessarily need to have strict control over, and we also want it to be reactive so that we could subscribe to it, et cetera. \n\n[00:06:40] And again, you could use both of them hand in hand."
    },
    {
      "number": 20,
      "title": "XState Store",
      "slug": "xstate-store",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/xstate-store/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: I'm going to demonstrate like these two libraries, or, sorry, these two types of libraries, by showing you one library actually. And so we're not going to be talking about XState, but we're actually talking about XState Store. Just because it is possible to use both of those approaches inside of XState Store. \n\n[00:00:22] If you've used Zstand or Jotai before, it's going to feel very familiar. So I'm using XState Store just to demonstrate the concepts. So we're going to first import Create Store from XState Store. And then here's what this looks like. We have two different types of things. We have the actual state that's inside the store. \n\n[00:00:47] And so in XState Store that's called context. So let's make a simple example like account. And then we have our transitions, which transition that state. So we have increment, and this is actually just a function which takes in the context and it takes in the event. So let's say that we have by and we want to increment it by some number and then we will just update the state so we spread the context in there. \n\n[00:01:22] And this is exactly as you would expect. The cool thing though is that XSTATE Store was built so that you have type inference. And so you don't necessarily need to say these are my actions. This is what the context looks like, because by default it can just infer those values. \n\n[00:01:40] And so with a store, you could subscribe to it. You could say store.subscribe and you could grab that context and then you could send it events, just like you can with useReducer or with xdate. But there's also a simpler way to do it too. We could do store trigger and then type dot increment and then you just pass in the payload over there. \n\n[00:02:04] And what that's going to do is that's going to log the incremented value. So that's the general idea of what a store is. It's a container of states where you update it indirectly via actions or sending in events just like that. Now, how do you use this in a react component? \n\n[00:02:30] So one interesting thing about stores, whether you're using Zestand or XState Store or a similar library like Redux, is that you can either pass it in through context or you can have this be standalone in something that you export. So let's say that we have a. Let's export a default page and we have a button that's just keeping track of the count. \n\n[00:03:00] So we want to subscribe to the count. So the way we do that, instead of using use date, we would grab the count from use selector. So we're going to grab use selector pass in the store and then we could read the counts directly from there. The reason that this is useful is because use selector is only going to re render this component when the count changes. \n\n[00:03:26] So you could do something like count greater than 10. And this is just a boolean value that's not going to re render every single time the count changes, but only when this value changes. So it's going to probably be false until it reaches that number. And in fact, let's try this console. \n\n[00:03:52] We're going to count the re renders over here. We're not using strict mode, so this might run twice, but and then we're going to show the counts over here counts greater than 10. So now if we go to local host exercise libraries, use clients [LAUGH] that gets annoying after a while. \n\n[00:04:26] So we have this button where we're not showing the count true false. Okay, so you see it changed to true. But the real question is how many times did it re render? Which I forgot to show you. So I'm going to reload this. So once you click increment, it's actually not re rendering at all until that. \n\n[00:04:53] And of course it rerenders twice because of react in strict mode, it's going to run the component twice. But you could see that no rerenders actually happen until that value actually changes. So that is a demonstration of using a store. Now, what about atoms? So atoms are a little bit different. \n\n[00:05:19] Like I said, atoms are something that you should use when the data can change freely, like from an external source. So let's say that I want to control this count using an atom instead the way that I would do that. And again, this is very similar to other libraries that will do the same thing. \n\n[00:05:39] We'll have const counts atom and we create an Atom. Oops, just a normal Atom with a value of zero. So now instead of using a store, we would just set the atom so we would count atom set. We don't need to get it. We could just get the value over here. \n\n[00:06:04] This is just value plus one. And then we could go ahead and log that count over here. But how do we get the count with xstate store, it's exactly the same way as you would select a value from a store. So we would say const count equals use selector. \n\n[00:06:24] We pass in the atom and then we could just, we could just give the value just for demonstration purposes and so you're going to see that this counts. Yeah, there we go. So now it just increments. And if we want to do something where you know, we want to see if it's greater than 10, then we could also see. \n\n[00:06:56] Let's also check the re-renders too. So you see there's no rerenders until it actually goes to over 10. So this is one of the key benefits of using these third party state management libraries, whether it's XState Store or different libraries, is that you can really reduce the amount of RE renders you have and you can make it so that you can say that components only care about the data that's relevant to them so they don't need to re render every single time any part of the state changes. \n\n[00:07:36] So that's a useful part of using either stores or an Atom-based approach is you have those fine-grained updates. Okay, so are there any questions on this topic? >> Speaker 2: I guess I'm trying to think of the use case for Adam particularly because I'm like, I don't know, I was like stuck on the idea of like with the store of like, okay, you're bulk buying and once you hit 10 bananas or whatever in your cart you're doing a 10% discount or something like that. \n\n[00:08:09] But the idea with the Atom approach be more so of like our whole shop, it's like a flash sale and it's like you're constantly trying to get like what is the discount or something like that where it's coming from anywhere. Or what would I guess be a. Better. \n\n[00:08:27] Use case of Atom? >> David Khourshid: Yeah, so a good use case of Atom would be just that. Let's say that you have something that is subscribing to store updates and then. Or like a shopping store update where it's like hey, no, there's a flash sale on this thing. And then you would just update that Atom directly or you could just do it as an event in the store. \n\n[00:08:49] But the idea is that that little piece of information sort of lives on its own. Like that flash update from a store doesn't need to or sorry, let's call it a shop. The flash update from a shop, it's not really related to the core data. So it might just be standalone in an Atom that you are updating from somewhere. \n\n[00:09:08] So we might have this hook like const use Flash sale and then you know, you would have some const Flash sale Atom and you might even instantiate this outside of the components where you're like set interval and then you know, you have whatever math dot random is greater than 5 sale no sale. \n\n[00:09:41] You know, something like that. So all of that logic lives outside. And then you could use that flash sale Atom and just. Yeah, so actually for instance, like let's say that we have account over here and this is the number of bananas that you want. So just call this bananas. \n\n[00:10:06] And so let's say that you want to increase the number of bananas. And if there is a flash sale, actually I'll just put this over here. But we actually want to select that. So const flash sale, we do want that. And then we want the counts of bananas. \n\n[00:10:29] So bananas and then we want the total value. So again this goes to lessons that we talked about before, which is deriving state. So we say const total price equals. And then flash sale equals sale bananas times 0.05, otherwise each banana is a dollar which is like Miami prices for bananas. \n\n[00:10:54] I don't know. So let's see. Flash sale equals sale. Should say no sale. And then this value isn't relevant. Okay, yeah, let's actually try this out. So again we have our total price and we have an external keyword being external data source, where it's just updating this, you know, this flash sale. \n\n[00:11:16] And so we could say H1 make it big. That's not what I. Okay, so you know, we might have a flash sale and then we want to show our total price over there. So now we'll go here and let's zoom in a bit. So there's a flash sale. \n\n[00:11:46] But now when there's no flash sale it sort of changes number, but you get the idea. I don't know why we don't have a banana emoji in there, but actually I'm glad that you mentioned that because right now we're combining. Let's do this. So instead of account atom we have account store and we're going to just increment that by one. \n\n[00:12:13] And so instead of this, we're just going to read that from the store. You can combine at least in xstate store you can combine stores and atoms together. And you could either do it like this or that changing value itself can be an atom. So we could say, let's just say yeah, everything is outside. \n\n[00:12:35] So we could just say const total price atom equals create atom. And then we're actually going to pass it in a function. And so we are going to just return. And this is so new that Claude has no idea what's going on. But we could say store get context bananas times oops wherever the times thing is and then flash sale item dot get if it's a sale then multiply that by 0.5 otherwise multiply that by 1 and then now in instead of this total price we could just select it directly from that total price atom that we have. \n\n[00:13:24] And so actually this shows you that we don't even need that selector anymore which might save us some re renders but now you could see that we're combining those atoms and come on flash sale there's no flash sale. There we go. And so you could see that price changing based on that. \n\n[00:13:48] So that's another benefit of using atoms is that you can combine them and so you could do things like that where it naturally or it innately handles the subscriptions and you know, things like that so it will subscribe to both the flash sale item and this store. So that's just how we can make state a little bit more convenient."
    },
    {
      "number": 21,
      "title": "External State Management Exercise",
      "slug": "external-state-management-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/external-state-management-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: So what we're going to do is we're just going to take, let's do five minutes. And so in these five minutes, what I want you to do is take a look at the page in exercise libraries. This is actually a pretty big, it's a pretty big multi step form. \n\n[00:00:23] It is much bigger than the one that we've done before where you could enter a destination like Minneapolis, you could go today, I actually went yesterday. So number of passengers, you could search the flights so you see all of the available flights, you could go back, you could select, then you would search for a hotel, checkout date, search for hotels, et cetera. \n\n[00:00:50] So it's really a giant multistep flight form. And then you could eventually confirm your booking and then you go there. So as you can imagine, we have a pretty, pretty big reducer that's helping us manage all of this. And then we also have to manually set up the context, which, that's a lot of boilerplate. \n\n[00:01:13] So in these five minutes I just want you to play around with either XState Store or if you have another third party state management library of choice like Zestand, I want you to just get a feel for how you would refactor this to use that third party state management library rather than relying on react context and use reducer. \n\n[00:01:39] All right, so let's talk about using third party state management. In this example, like I showed you, we have a giant reducer and this, you know, comes with a lot of baggage. We have a lot of, we have to use context, we have to pass it down. There's a bunch of boilerplate. \n\n[00:01:59] And let's say that in your team, you decide that you want to abstract this into a third party state management library because you might have performance issues or you might want to reduce the amounts of code that you have to maintain. And especially with raw hooks like useReducer or use context, there's a lot of room for developers to make their own abstractions or their own patterns that they just hope that the other developers will be on board with, even though it's usually the case that they're going to end up disagreeing with each other. \n\n[00:02:33] And then you have multiple abstractions in the same code base. And this is another reason why I think third party state management libraries are great because they provide an opinionated approach to, to managing this kind of states. So taking a look at our booking reducer, I'm actually going to split the screen here, but we, this is a common theme. \n\n[00:02:54] We are going to be doing the same thing that we've done in other exercises where we're doing things side by side instead of doing a wholesale replacement of it. So instead we're going to have in this case a booking store. And we are going to create a store. \n\n[00:03:13] We're going to have our context and our context is going to be that initial state. So it's going to be the same as the booking state over here. And then we have all of our transitions that we could do. So just to show you one, as an example, we have flight search updated. \n\n[00:03:32] We get the context and we get the event. Sorry, the event is going to have a payload and that payload is going to be. This is where making explicit types really help. So we see that the payload is over here. There's a couple of ways to bring this out. \n\n[00:03:58] We could either just have a type flight search updated events and just pull it out over there, or we could derive that type. So the way we would derive it. So I'll just do it here. So flight search or flight search updated events payload. But the way that we could derive it, if you don't have this separated out into a type, is you could. \n\n[00:04:30] This looks a little bit ugly, but basically you could say this would be a booking action and you intersect that with type flightsearch updated and then you read the payload from that. Again, a little bit ugly, but that's why it's good to have just some more explicit types with that. \n\n[00:04:51] And then you're going to update it like this. And then you could do this with the rest of the actions you have, just converting them over. And again, we're doing things side by side. So we have a convenience use booking hook that we could use. And so this is where we could actually just read in the store. \n\n[00:05:16] Yeah, read in the store context. So we could say const storecontext = useSelector. Then we're going to be reading the bookingstore and reading in that context from there. So this context, confusingly enough, includes both the state and the dispatch. So what we want to do is, you know, we want to have the. \n\n[00:05:53] What do we wanna do? Yeah, so we want to do our console log. So we want to say console log store context. And we also want to compare it to the context.state. Again, I know that's a little bit confusing, but the reason that we do this is that when we're working in an application where we're doing this kind of refactor, we want to see that everything is still pretty much the same. \n\n[00:06:22] So for example, if we are entering our destination we want to see that the. Oops, let's see what I did wrong here. Store context. Wait, that's, there we go. Okay, it's giving me a whole bunch of junk. But we want to see that essentially both types of states are exactly the same. \n\n[00:06:50] So in this case we have CurrentStepFlightSearch, CurrentStepFlightSearch. And once we start doing things in parallel, we could see that the states match up. And so once those states match up, that's when we're going to be able to confidently remove the old implementation and replace it with a new implementation. \n\n[00:07:13] So I'm just going to show you, for sake of time, the end result. And so we no longer have any context, just fold all. So we no longer have any context because we're just bringing that directly in from the store. And so you could see that, you know, we have the step, we're reading it directly from the booking store over here and it has everything that was in our, our original reducer just like that. \n\n[00:07:47] So now instead, again, instead of using context, we use selector, grab it from that booking store, which we could put in a separate file, import that, and then we're reading the state and only the state that we need. That's the key difference here. And then on things like handle submit, we could trigger the search flights event and pretty much everything else remains exactly the same. \n\n[00:08:11] So we're using that pattern of selecting from the store and then dispatching or sending an event. And so this is going to actually be pretty much the same approach. Whether you use Redux Toolkit or Zustand or XState Store, you're replacing that useContext useReducerdance with a third party state management library."
    },
    {
      "number": 22,
      "title": "Flattening Nested Data Structures",
      "slug": "flattening-nested-data-structures",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/flattening-nested-data-structures/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Okay, the next topic that I want to talk about, which has come up in previous questions and conversation, is data normalization. And so the key part of this is avoiding nested and deeply nested data structures. And we want to do this for two reasons. The first reason is performance. \n\n[00:00:21] So when you have a flat data structure, then you have either constant lookups or lookups of at most o of n instead of O times m, which just gets exponentially bigger when you need to find a specific piece of data. So that's why keeping things flat is really useful. \n\n[00:00:44] And the second reason is because you want to make things easier to both update and understand in your code base when it comes to nested data. So one of the examples that came up was nested forms. And so let's say that you have a nested form where you're managing, just going with the same travel theme, you're managing multiple passengers. \n\n[00:01:08] And each passenger has a name. They have a passport number, a known traveler ID number, birth date, et cetera. So the way that you might model this at first is you would say, okay, yeah, this is definitely a just a nested form. We have passengers as an array, and then inside each array is an item with even more things inside. \n\n[00:01:29] And so they might have, let's say you have to put in countries you visited. So now there's even more nesting going on inside of that object. And so, it becomes difficult to update those items because you have to drill deeply into that object structure. And also, it actually is bad for performance too. \n\n[00:01:54] And the reason it's bad is because when you're updating something that's deeply nested, you're not only updating that specific item, you're also updating that item's parents and that item's parent's parents, et cetera. And so anything that only cares about the parent is at risk of re rendering, even if it doesn't care about the child's data inside. \n\n[00:02:16] And so this is why data normalization, it's very good for those two reasons, both performance improvements and also understandability. What we're going to do is we're actually going to learn to normalize data and we're going to be doing the same approach where we're doing things side by side. \n\n[00:02:37] But I'm just going to show you an example over here, normalization page, and I'm just going to actually make a quick oops, quick demo page. So >> David Khourshid: Let's say that we have that same example where we have const flight data. So we might have a, you know, reservation ID and that might be a string, you know, flight number or we might have like a flight related to that. \n\n[00:03:18] And then we might have some passengers. And so each of these passengers will also have some ID. So this might be John Doe, etc. And we might also have visited countries and then we have a lot of nested data going on. So we have our flight inside, we have the reservation ID inside, et cetera. \n\n[00:03:42] There's just a lot going on here. In fact, let's make another passenger, Jane Doe, they both went to the same three countries. So when you want to update, for example, the name of this passenger or the visited countries, the problem is that we're essentially just changing every single part in this structure and you're potentially causing a re render for anything that relies on anything inside of this flight's data. \n\n[00:04:12] So what can we do instead? Well, let's actually make this bigger so we have const flights and then we might have a, or let's call this itinerary. And in our itinerary we might have a bunch of flights and inside that we might have like flights data over here or actually let's call this reservations because our itinerary might have multiple reservations. \n\n[00:04:43] So let's have it generate another one over here just for an example. So instead of having a deeply nested data structure like this, what we could do instead is we could flatten this a little bit and for example, let's pull out passengers over here. So what will this look like? \n\n[00:05:03] We'll have a passenger, so we'll have the same information right over here. And instead we're going to relate it to the reservation. So we're going to have a reservation ID for example, 123 and same thing over here. So let's just get rid of this. And now the difference is that we no longer need to nest that data deeply inside of there. \n\n[00:05:32] We could even do the same thing for flights if we wanted to. But just for demonstration purposes, we're going to flatten just this one area. So now let me just do a split screen over here. Before, when we were looking up, for example, the passengers of a specific reservation we would have to do const passengers equals itinerary reservations. \n\n[00:06:02] First we would have to find the reservations. So we would say r.i =, let's say it's equal to 1, 2, 3. So that's the first level where we have to look at. And then we would have to just grab, let's grab a specific passenger. So then passengers and then we have to find that passenger from there as well. \n\n[00:06:32] So we're doing a lot of nested searching. But when we have a more normalized structure besides the performance benefits we get, let's say we have a const johnPassenger. We could look directly at the passengers. So we could say itinerary.passengers, where the passenger reservationId is 123 and the passenger id is John Doe. \n\n[00:07:10] So that's just an example. I mean they're around the same lines of code, but the difference is in the. And that's only because we're word wrapping see that one's actually shorter. But you are going to see benefits in performance and also your data structure is going to be a lot simpler. \n\n[00:07:28] And the third thing too is going back to a previous exercise that we did. When you're modeling things in an entity relationship diagram, everything is flat, so there is no nesting. Everything is related to each other via those foreign keys. And so we could model that exactly the same and see similar benefits in our front end applications as well. \n\n[00:07:52] So that's where data normalization just becomes very useful."
    },
    {
      "number": 23,
      "title": "Data Normalization Exercise",
      "slug": "data-normalization-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/data-normalization-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Let's jump into the exercise. So this is actually going to be a pretty fun exercise. We have a different part of the application here. Oops. There we go. So if you go to the normalization exercise now, you're going to see somewhere where a user can enter their travel itinerary. \n\n[00:00:23] And so we're using a reducer for this. You could add a destination. So let's say that you're going to Osaka. You want to, I don't know, eat sushi and see the ocean, I don't know. And then let's say that you have another destination like Tokyo, where you want to visit team labs and eat more sushi, whatever there is to do in Japan. \n\n[00:00:54] And this is nested data. So you have this, you have destinations, and so we have multiple. And then you have to do items in each of those destinations for the travel itinerary. But what we really want to do is simplify how all of this works so that we don't have to go deeply into the destination and then find the to do item so that we could do things like delete it and things like that. \n\n[00:01:22] So looking back at the page, we see that we have a destination within the array of todo items. And then we have our to do items over there. And our goal is to simply normalize that data so that it's not nested. And if you want some fun state challenges too, then you could do things like focusing the destination input. \n\n[00:01:46] So, for example, if I add a new destination, well, it already works like that, but you could work on, for example, if you say something and then you press add, it should focus back on that field. It's a fun exercise. And also we're going to be taking a look as a bonus at implementing undo and redo and just seeing how that works, because I think that that is a very advanced but important state management skill to learn. \n\n[00:02:22] >> David Khourshid: All right, let's normalize some data. So again, we have to do item being nested inside of destinations under this TO DOS array. And we have all of our destinations in here. So I'm going to be like a broken record. We're doing things side by side without. Without deleting code first. \n\n[00:02:41] So we are going to put our TODOS in to do item. And we're also going to be adding another bit of information. We're going to be giving a relation for what destination it belongs to. Now, immediately you're going to see some red, which is great because the red really helps us out and tells us you updated this. \n\n[00:03:04] So now you need to, you know, make sure that everything is updated. So let's say const. New to do. Oops, not you new TODOS. And we're going to give it that random id the text, but we're also going to give it the action.destination ID, which we already have. \n\n[00:03:26] So we could pass in that new TODO here just to make typescript happy. But what we're also going to do is we're going to add this to the TODOS array. So we're going to just push it here. By the way, I really like doing state TODOS. Concat. It's up to you. \n\n[00:03:45] You could do that. You could do the spread operator. I don't think it really matters. All right, and then there is one more red part over here where we need to add that array of TODOS. So are we done? Not exactly yet. So we have almost normalized our data, but we still have this array of TODOS. \n\n[00:04:11] So we'll go ahead and comments that out and then we could just remove that. Let's see, there's some other red over here. So this one, we actually don't need this anymore. And this is one of the main points of this, where we don't really need to keep around this boilerplate code for going deeply into a structure, because, yeah, we could just delete that code. \n\n[00:04:44] So same thing over here, we're going to filter the TODOS and this becomes a less expensive operation. You could do even further normalization by using an object instead of an array, where the object keys are the IDs. So this is a form of normalization, but again, you could go further, and it's actually much faster if you use an object technically, because it's an O of one operation versus an O of N operation. \n\n[00:05:14] But just to make things simple, I like keeping it as an array and because that also preserves the order of the items too. So that's one of the trade offs that you have to think of when you're deciding to normalize via an object or an array. And there's also one more hidden thing over here, which is this. \n\n[00:05:33] When you delete a destination, now you also have to filter through the TODOS and you have to make sure that any TODOS that are related to that destination are gone as well. So I mean, they're still going to be invisible because you're deleting the destination so they don't show up in the ui. \n\n[00:05:53] But it's just nice to do. And especially if you're syncing with a server, you don't want to have those impossible states of orphans to do items that are trying to relate to a destination that doesn't exist. All right, so now this code is going to become a lot simpler. \n\n[00:06:12] We have our destinations over here that come from the state. So now we could just read the to dos and actually, we might need to do something a little bit different here. So we split screen this. We need to split this out into its own components. And here's the way I like to do this. \n\n[00:06:39] It's actually pretty common in React apps, especially big ones, where it's like, okay, I'm just going to map through values, and then I'm going to use this convenient inline function to just put everything in there. And then you realize that that gets pretty big, and then you have to use a hook for something. \n\n[00:06:54] So then it becomes a little bit annoying, the fact that you inlined all of this stuff. And so, that's why I do recommend just creating individual components whenever it's feasible. But, sometimes it's not. And we could just create a. We could refactor. Anyway, so let's make a function destination and we're going to have the destination, and then we're just going to return everything inside that card, unless it doesn't let us. \n\n[00:07:26] There we go. And then we're going to see a bunch of red. [COUGH] So this is another important thing to talk about. When we had it inline, we already had dispatch and things like that. So there's a couple of different approaches for solving this. We could either pass dispatch directly in here if we wanted to, or the other approaches, we could abstract that away and make this component truly standalone. \n\n[00:07:57] So we could say, for example. Onupdate, destination, etc. For simplicity, I'm just going to pass in dispatch here, but you could do whatever approach works best for you. So this dispatch we are going to have action void and then most everything should work fine. So we will remove that for now. \n\n[00:08:32] Now we also need to grab the TODOS, so we could pass that in through here and then this is going to be just our array of TODOS that are related to that destination. So now instead of destination todos we would have TODOS length. Instead of destination TODOS map, we would just map over the TODOS and so now we can take this card and we could replace it with our destination, which is in here. \n\n[00:09:11] And then the TODOS are going to be the TODOS where the todo destination ID matches the destination ID. Still getting an error here. So let's figure out what's going, we need a key. Of course. Another thing too, always prefer to have a unique ID when it comes to mapping over something. \n\n[00:09:38] I know we've all done the habit where we use indexes and things like that, but the most reliable thing is going to be a key. And so the reason why is that things can change order and then the UI states. So the natural DOM state of whatever component is being worked on is going to be completely lost. \n\n[00:10:01] So imagine you have, for example, a list of TODOS, each of which has an input or something, and you're typing somewhere and then another TODOS is prepended to the list. Now, because that index is different, React treats that TODOS item as a completely different component and so you're going to lose focus. \n\n[00:10:20] So that's why if you have the ID, that won't happen because that ID is going to stay exactly the same. So that's another mini lesson there. All right, so everything mostly looks good. We've normalized our data. We no longer need those to. There's another small thing that I want to talk about. \n\n[00:10:43] In our TODO item, when we have like a destination ID, like for example, it's just a string over here and we're just creating a TODO, and we're passing in the destination ID, absolutely nothing. And this is really interesting, nothing is stopping us from doing this or even just doing like a TODO ID or whatever. \n\n[00:11:07] So we could put anything invalid in there. Are there any guardrails that can help us just sort of prevent this anti pattern or not really an anti pattern, but just a potential for errors to happen? The answer is yes, and it's by. This is sort of an advanced typescript technique. \n\n[00:11:28] It's called a branded type. So it looks like this type brand B and we're gonna do a simple version where it's just a string and we have this weird little object over here. Basically this creates a special type that says it is a string, but it is a special kind of string. \n\n[00:11:50] So just to give you an idea, we might have a destination ID and we could give it the brand of destination ID and we can also have a TODO ID which we could give the brand of TODO ID. Functionally, these are strings. They're going to work just like strings. \n\n[00:12:06] And as far as the runtime is concerned, they are strings. We're not adding any extra properties to it or anything like that. But here's the key, when we put this in there and we put that branded type, we immediately see red because it's like, hey, we can't actually guarantee that this action destination ID is really a destination ID. \n\n[00:12:31] So now we have to enforce that upstream. So we could say this should be a destination ID and now we're going to get read somewhere else. And so destination ID, if we go to destination, we could say every destination. Wait, that's destination. Let's call this destination card. Okay, so destination where was, nope, this is what happens when I use the same name for things. \n\n[00:13:14] But anyway, so in the destination, we could say that whatever ID is in here is definitely a destination ID and whatever ID is here is definitely a TODO ID. And so when we're actually creating that, we can coerce, for example, this random UUID. We could say this, just assume that it is a destination ID because we're creating it from scratch, so we have full control over there. \n\n[00:13:42] So same thing over here, we could coerce this to be a todo ID and so now when we're here. All right, so now let's try doing something bad. Let's say we're updating the destination and we do some junk over here. It's not gonna yell at us because that's still a string. \n\n[00:14:08] And so we need to change it in a couple of other places. But now we're going to see red and it's going to be because we are not using the correct branded type. So, oops, so we could change that and see that it's fixed. So we have destination ID and now everything is fine. \n\n[00:14:33] So, when we create a todo so over here, we can be sure that we're not just putting in any random destination ID, but we're actually putting in an actual destination ID. So that's, yeah, any questions on anything I showed you there so far? >> Speaker 2: Curious of so I've seen something similar to the branded type, and I've seen people like really lean into enums to try and avoid using strings anywhere in the application. \n\n[00:15:20] So like for instance, on your types, rather than using string add to do, you could just do like an enumerate and then have like a set of different actions, would you say there is any drawback or benefits to between the two? >> David Khourshid: I think that there's plus and minuses to both approaches. \n\n[00:15:45] Personally, when I'm working on an application, I will first start off with just the strings, just because I know that if I make a typo here it's it's going to yell at me anyway. And also, I do still get autocompletes when I do. Do that. The downside though, for that, and this is one of the benefits of using enums, is that, you see, I'm trying to rename this element and it's saying, I cannot rename this element, at least not at the moment. \n\n[00:16:12] Just because a string is a string, just because it happens to be in an object, doesn't mean that we could replace all usages of the string with whatever we decide to put there. But if we use const enumeration, action type, and then we have something like this, and then we replace this with action type, dot, add destination, then you know that then we could actually change that, I believe. \n\n[00:16:40] No, you can't. But I mean, you could change it here. And also if you change this, it doesn't matter because that value is going to be the same. And so that's why you're going to see red there and it's going to be like, hey, you should probably just do this. \n\n[00:16:57] So I do see the benefits of it. I would say Enums and TypeScript are a little bit messy. If you are going to use enums just because of the way they implemented it. If you are, then I strongly recommend using const enums just because I believe, if I'm not mistaken, that they're just the runtime values are just the strings. \n\n[00:17:20] It's not like some crazy enum object. It's just going to be a string. >> Speaker 2: Yeah, well, and I think with the enums, if you are using it only in type references, it's going to strip it. The TypeScript compiler will strip any of the enum types if you don't use them as a value. \n\n[00:17:47] Whereas if you use them as a value, then it will. It has to force it as an object, essentially. >> David Khourshid: Right? Yeah, I believe so. But in this case, because we're, in the actual code, output is going to output as these strings, literally. So, yeah, but, yeah, so that, that's actually a good example of, like, if we go to finite solution, over here we have this stuff. \n\n[00:18:17] So you could actually say flight status. This could also be an enum too, so const enum flightstatus. And then you have idle submitting error success. And so instead of, for example, checking if something is submitting, like over here, you could just use that enum. And, and so from what I've seen when working alone, enums sort of get in the way because it's a little bit more boilerplate to write. \n\n[00:18:46] But when you're working with a team, it's actually pretty useful to have that enum and sort of enforce that with your entire team. So I think I lean on the side of using const enums over just plain strings. But when you're starting out, just start with the string and then refactor to use that enum, or let cursor do it for you. \n\n[00:19:08] >> Speaker 3: How do you decide on the relations between the data types? So, for example, you put an array of destination IDs on the todos. Is the reason you did that instead of putting an array of to do IDs on destinations? Or is it pretty much the same? >> David Khourshid: You mean when we first had the state? \n\n[00:19:33] >> Speaker 3: When we were building the one we were flattening it out. >> David Khourshid: Right, so the first one before the flattening. And that's because a destination can contain many TODOS and the TODOS cannot contain many destinations. So it is a one way thing. But I mean, it does get tricky. \n\n[00:19:48] So like for example, if you have, if you have friends, like you want some model friends, like this friend has all these friends and this friend has all those friends. The friends can be friends of each other. You have a many-to-many relationship. It's like, okay, so how do we represent that? \n\n[00:20:04] With the nested data structure, it becomes a little bit tricky because it's like which one is a child of which? And then you have a lot of data duplication. Whereas if you have a flattened structure, then you could just represent the relationships like friend of or just a separate, I hate to say join table, but you know what I mean? \n\n[00:20:22] Like just somewhere where you're keeping track of the relationships between those different entities."
    },
    {
      "number": 24,
      "title": "Undo & Redo Events",
      "slug": "undo-redo-events",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/undo-redo-events/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: I wanted to show you one more really, really cool thing and this is definitely, it was an extra credit item, but I don't expect you to build it out. So, normalization solution. And it goes to the original principle of events are the actual source of truth. And so let's say, like you see over here we have these two grayed out buttons. \n\n[00:00:28] Over here doing undo redo for text is easy because it is just a text area. You already have the browser's built in. Command or control Z command or control, Whatever the other one is, I'm blinking or control Y axis. It depends, there's different key mappings for redo. But the idea is that when you're working in an app where you have to make lots of changes, it actually is a pretty common request to say, hey, we do want to represent undos and redos. \n\n[00:01:05] And so by representing or by having events and events driven architecture, instead of just updating states, you actually sort of get that almost for free. So I wanted to demonstrate that just by showing you first the implementation and then how it looks. So in this reducer I actually have two extra events. \n\n[00:01:29] Over here I have undo and redo. And I also have a couple of extra fields in this date. I have the events, so we're keeping track of which events occurred. And also undos, which events were undone. So without changing too much of the actual data structure inside the reducer, when my action is undo, imagine that we have done a bunch of things here. \n\n[00:01:59] We entered the destination name, like Timbuktu, and added a few to do items over here. You could see that each one of these is an event. We created a destination, we created a to do, and then we created another to do. So what would undoing be? Undoing. Since we know that we're going to reach the exact same state if we replay all of those events, undoing is just replaying all of those events minus the last one. \n\n[00:02:32] Now, in reality, doing undos and redos is a little bit more complicated than that. But just for basic purposes, replaying all of the events up until the last one is more than sufficient. So if we go to solution over here, we can see that when we undo, we're replaying all those events and we have built in undo functionality. \n\n[00:03:00] So I'm going to undo again. And redos works similarly. So whenever we undo an event, that event goes into an undo array or a stack and then when we redo, we are just popping from that stack and then replaying just that event. So we already have the state for n minus 1 events. \n\n[00:03:23] So we just replay that event and that's essentially a redo. So we could basically redo and yeah, then we could rebuild everything just like that. And so that's why I really like events, because they contain all that extra data that allows us to do things like undo, redo, makes it easier to debug and things like that. \n\n[00:03:51] >> Speaker 2: Could we have a recursive reference to the previous state? And when we undo, do we have to check does state equal the previous state? >> David Khourshid: Could we have a recursive and can do state equals. State equals state previous. So that's another thing about events. Events are tiny. \n\n[00:04:16] Imagine that you're building this to do list. You have 3, 4, 5, 6 to dos. And so you add them all up, it becomes a lot larger and you're having to keep track of these huge objects and there's a chance that you could run out of memory pretty fast if you do that. \n\n[00:04:35] And so events are smaller and you're going to get to a consistent state when you replay those events anyway. So, yeah, I would say that definitely is possible. And you could also, instead of keeping track of the entire previous date, you could keep track of state's diffs. But at that point, a state diff is essentially just a raw event. \n\n[00:05:02] It's telling you something happened. The state changed. We don't know why it changed. So it's just a very basic kind of event at that point anyway."
    },
    {
      "number": 25,
      "title": "Avoiding Cascading Effects",
      "slug": "avoiding-cascading-effects",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/avoiding-cascading-effects/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: I'm excited for the next one because it's very painful. So it is on cascading effects. This is something that is almost inevitable when you get into bigger and bigger projects. What happens is that you have some states, whether it's in use, state, useReducer, wherever, and then you have multiple use effects that are cascading. \n\n[00:00:30] In fact, I think that this is worse than having a use effect that runs on an infinite loop accidentally, because these are just very hard to track down. I know I've been talking about state machines a lot, but when you have useEffects at cascade, it's more like a Rube Goldberg machine where something is happening. \n\n[00:00:49] And it touches something else, which triggers something else, and then that touches something else, and then you have this cascade. The side effect of this is that you're not sure where data is updating or when effects are being executed. You're just hoping that if I put everything in the dependency array and then I have a conditional set inside of my useEffect that says only run this effect if this conditional is true. \n\n[00:01:18] So you're sort of filtering from everything you're putting in that dependency array, it just becomes very confusing, and so bugs become very hard to track down. There have been many times where I have had to myself debug these multiple useEffect hooks, that cascade. And I had to do things like comparing the previous dependency array with the current dependency array to comparing each item and seeing which of those items changed. \n\n[00:01:48] And then once I identified, hey, this item is causing this effect to run when it shouldn't run, then I would have to backtrack and see, okay, where can this item be possibly changing? And so when you don't have events, you are really having to depend on when data changes, and that just becomes very confusing. \n\n[00:02:10] So this is an example over here, where we have an effect that triggers when the inputs change. And then we perform the flight search, and then the hotel search is triggered when we select a flight, and then we perform a hotel search. And so this can be, for example, a component that tries to show everything in one page, which is pretty common, but in order to do that, we are just chaining these useEffects together. \n\n[00:02:40] And even though this looks simple enough, when you add the actual implementation of the useEffect and these dependency arrays grow, it just becomes very confusing. So the way that we could do that, or, sorry, the way that we could avoid this problem of these multiple chained useEffects, is by, well, reducing the number of use effects and using a reducer. \n\n[00:03:07] And this also gets closer to our idea of declarative effects too. So when you have a reducer, you could basically say that if we for instance have flight updated. We could have a single use effect that manages whenever this date changes, I need to do the appropriate effect for that state. \n\n[00:03:30] So this is the end result of doing things in an events driven approach. But how do we actually get there? So what we want to do is actually work backwards, look at all of our use effects and also observe the running application and see when are things actually happening. \n\n[00:03:49] So what data is changing? And can that change of data instead be represented by an event rather than it just changing in the use state? And then that's triggering a use effect. And so if it can, we could refactor to using an event and then just executing effects based on the state."
    },
    {
      "number": 26,
      "title": "Refactor Cascading Effects Exercise",
      "slug": "refactor-cascading-effects-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/refactor-cascading-effects-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: We have a lot of useEffects here and this is all powering this component where let's say that we have a form. I like to call this an I'm feeling lucky page because it automatically chooses a flight and a hotel for me. So if I, for example, want to go to Tokyo and I put a start date and I put an end date, then it's automatically going to trigger this flight search first. \n\n[00:00:32] And then once it finds a flight, it's going to find the appropriate hotel. And then whenever I change something, so let's say I want to go to Berlin instead, it's going to restart that search and it's going to restart that hotel search and same thing, if I change the date, it's going to restart everything. \n\n[00:00:52] So yeah, that's an example of a feature that would be cool except the code for it is a little bit of a mess. So what I want you to do is start refactoring this into a reducer with events and then reduce the number of use effects to a single effect. \n\n[00:01:20] All right, so let's get rid of this use effect chain that's causing us a lot of pain. I don't mean to rhyme, but it just came out that way. First, let's set up our booking state. Because we do, since this is going to be an event and state based approach, we do want to use a reducer. \n\n[00:01:41] It's not 100% necessary, but it does really help here. So this could be in one of these statuses either idle searching flights, searching hotels, or you know, maybe we have an error state and then we have a bunch of inputs. And so these inputs are represented by everything over here. \n\n[00:02:04] So we have our destination, our start date and also our end dates. And then we have a few other things to add too where we want to represent the. For instance, the selected flight. And again this should be selected flight id, the selected hotel id and also just an error could be string or null. \n\n[00:02:29] This again is how I would start out. And you could later use discriminated unions if you want to. So then we are going to actually create the reducer and yeah, so let me just const booking reducer. We also need our actions as well. And so this is something where it's really useful to first play around with the UI and actually see what is happening at an abstract level. \n\n[00:03:05] Because in this application we don't really have events or we don't have actions or things like that. Instead it's just data changing that's triggering all of these use effects. So the first one we could see is that we're triggering something when our inputs update. So we could, let's just type action here, let's call this input updated. \n\n[00:03:36] And so we have our inputs over here. And so this would be like the destination, start date, end dates and it could be some of those. We also have the flight was updated, so type or sorry, the flight was. Yeah, so chosen or I'm just going to call it updated. \n\n[00:04:03] And then you know, we have our flights data over here or the hotel was updated and then we'll just stick with that. So I'm going to put state over here and then we have to actually go through our actions. So if the input was updated, then we are going to return the state with the updated inputs. \n\n[00:04:29] Now here's where things actually get a little bit interesting. Let's const inputs equals the state inputs and everything. So we actually don't need to do this. Now if we have the inputs.destination and we have the inputs start date and the inputs end date, then we actually want to go directly to searching flights. \n\n[00:05:05] So this is something that we previously used a useEffect for. So you could see over here we're triggering that whenever we have all three of these things we set issearching flights to true and error to null. And so instead we can avoid a rerender, and we could centralize that logic. \n\n[00:05:25] So we could even add a comment here that say if all the inputs are provided, then we want to trigger flight search. So when the flight is updated we immediately want to start searching for the hotels, but we also want to have our flight id. And then when the hotel is updated we want to, we want to set the hotel ID and then just go back to an idle state. \n\n[00:05:59] And so what this is going to do, and I'll just show you the end result is it's going to reduce the number of useEffects we have down to one. And the reason that it's only one instead of all of these four is that now we're basing what we should do next on what the state is, so what the finite state is. \n\n[00:06:20] So if we go to effects solution page we could see we only have a single use effect. Now we have our reducer over here and in this use effect we're determining what to do based on the status. So if the status is search flights, this is where we actually start searching for the flights. \n\n[00:06:43] If the status is search hotels, then we search hotels in here. And all of this is based on states. So you can even abstract this into a custom component. Or you could abstract both or sorry, not a custom component but a custom hook. Or you could abstract both of these into a custom hook and it would look something like function usetrip search and you would have this reducer, you would have your useEffect from below over there. \n\n[00:07:15] So this would be whatever that useEffect block was below. And then you would just return state and dispatch as a table tuple. And then what you could do is instead of all of this, you could just use trip search and all of that logic. Both the states and the effects are centralized in one single hook. \n\n[00:07:46] So we've eliminated the number of useEffects we use. Everything is declarative, we have dispatches. But yeah, so that's the general idea of reducing chained use effects. So, any questions on that? By the way, the solution in this is not perfect. So I invite you to take a look, see if there are things that can be improved and fix them yourself. \n\n[00:08:18] But it does go to show how we can remove those unnecessary use effects."
    },
    {
      "number": 27,
      "title": "State Management with URL Parameters",
      "slug": "state-management-with-url-parameters",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/state-management-with-url-parameters/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: So what I wanna talk about now is using URL, the query parameters for state management. This is something that is typically overlooked because it's just not something we think about. And also it's sort of difficult to do, especially if you're using a framework like Remix or Next, they don't make it the easiest thing to synchronize state with the URL. \n\n[00:00:28] However, in many web applications, and this goes back even to the early 2000s, 1990s, the URL was actually the source of truth. So think about it. Let's say that you want to have some sort of form or some sort of view where you're searching for things and you want to actually have it so that the URL maintains the state, so you have everything in query parameters. \n\n[00:00:57] There's a lot of benefits to this. First of all, the form data is not gonna be lost on page refresh because you already have that data in the query parameters and you could use it directly on the page. Also, that long string with the query parameters, you can bookmark it, you could share those URLs. \n\n[00:01:17] And the back button is actually going to work and preserve that form state because we're using the natural history mechanism of the browser to maintain that state for us. So again, URLs are really, really overlooked when it comes to state management. But honestly, a lot of our applications can really benefit from using the URL as a source of truth for state. \n\n[00:01:42] There is an external library called nuqs and N-U-Q-S that does make this pretty easy to do. And I'm going to demonstrate to you how nuqs can make this a lot easier. But first let's take a look at the actual problems that we're dealing with. So if you go to exercise-URL, we have our flight booking form as normal. \n\n[00:02:08] We have our one way flight, we could put in a destination, our departure date, the number of passengers, and search for flights. You know what, I don't actually wanna go to Tokyo, so let me go back and change that to Osaka. Wow, okay, so everything changed except the number of passengers for some reason. \n\n[00:02:33] But everything changed and everything disappeared. And now as a user I'm a little bit frustrated about that. So that's just not cool. So if I put a destination here, go to search flights and let's say that, okay, I actually like these results for this imaginary place that I searched and I want to sort by duration, see the direct flights, and actually share this with one of my friends. \n\n[00:03:05] I can't because there's no query parameters, there's nothing for me to share that basically when I reload, first of all, this view is going to go away. And even if that view didn't go away, like if it was a different page, I would lose all of my results. \n\n[00:03:21] So it's just really not a good situation. All right, so how can we actually fix that? So if you go to urlpage.ts, we are going to use a library called nuqs, N-U-Q-S. So we have a bunch of use states here. And we've done so many exercises where it's like, okay, yeah, let's consolidate these, let's put them in a reducer, et cetera. \n\n[00:03:48] We're not actually going to be doing that here. Instead we're going to be replacing this useState with use query state from nuqs. The only difference here is we want to give it a name. So it's going to be, for example, usequery state destination and then this is going to be usequery state departure arrival. \n\n[00:04:16] This is what shows up in the URL. And then this is one way set is one way. This one is a little bit different. All of these are strings, or we could use them as strings. But with usequery state, it assumes that since the URL is a string, everything's gonna be a string. \n\n[00:04:37] It's not the case over here. We actually want to parse this as a Boolean value. And so the way that Nuqs works is we have a way to parse the value and so you could return the value as true and, and then you could go the other way around. \n\n[00:04:52] And so, based on the value that is set, we would set that to true or false. Or we could do things like set this as one or zero, it just needs to be a string. But Nuqs does have a lot of shortcuts for that. So we could just parse as Boolean and then give it a default of false, for example. \n\n[00:05:19] So now let's see this in practice, when we go back here, we are now going to see an error value prop on input. Interesting, don't care. So you are going to now see that when I toggle, for example, one way flight, it's updating the URL for us. And also because the default is false, that actually disappears when we set that to false. \n\n[00:05:47] So now we could enter a destination and you could see that it is changing in the URL as we are changing that. And also it's not pushing to history, instead it's replacing the history. So you're not going to get that annoying thing where when you go back it's toki and then you go back it's toke, etc. \n\n[00:06:10] Instead it's going to treat it as a single transaction. Then we could set the date. So we set the departure number of passengers. I think we forgot to add that in, it's okay. The idea is that when we search flights and we go back to our search, none of our data is lost, which is really awesome. \n\n[00:06:33] So if we take a look at the search results, then we could basically do the same thing over here. So this, we might need to change it because this needs to be an id. And so this goes back to an earlier lesson. Instead of duplicating states, we want to really instead derive it. \n\n[00:06:56] So we would want to set the flight id. And so this one, we use query state parses Boolean with defaults false. And there's another one here where we could parse as enum or. Sorry, it's not parse as enum, it's something else. It is, parse as string enum. Be careful of AI coding assistants because they will hallucinate different answers. \n\n[00:07:25] But yeah, so you can have things that go beyond a string and you could also have these string enums. We're deriving state over here, which is good, but yeah, so now we should see that this works when. And you could see that it's actually changing over here. When we actually change ascending, descending, etc, it is going to change in the URL. \n\n[00:07:54] So there's one more thing to do which is, let's see, forget what it is. Yeah. So if we go to the solution, because the other problem here is that if we reload it is going to go back to the original screen and we don't necessarily want that. So the way that we solve this in the solution is that we actually have a view variable. \n\n[00:08:29] And so just to show you what that looks like, we have view, set, view and then we're using query state of the current view that we're on. So having this in the reducer makes this a little bit easier. But yeah, so yeah, so that's a basic intro to using the URL query parameters estate. \n\n[00:08:57] It's something that I really encourage. Like when you have something where you want the URL to be shareable, you want the URL to be the source of truth. For part, if not all of your components in a certain view, definitely consider using the URL query parameters for states. \n\n[00:09:16] >> Speaker 2: What if instead of using a view parameter, we just check to see if history has anything pushed to it. So just if they essentially go to the URL and there's no history, there's nothing to go back to, then you could assume that they're going straight into the view of results. \n\n[00:09:40] >> David Khourshid: Potentially, yeah. And that could work in some cases. I just like to be explicit. And this view equals or step equals. This is something that you will see commonly in URL query parameters anyway where it explicitly says which step you're on. So it's a difference between implicit versus explicit states. \n\n[00:10:07] >> Speaker 3: And just to double check here, the first couple params, that's actually from the first page. >> David Khourshid: Yes, and that's so that we have that. And look, if I go back, oops. Or forward, I did that wrong. We could go back. We could go forward and get those search results back. \n\n[00:10:29] And forward works pretty naturally, which is pretty nice. But yeah, going back to the original question of what if the user changes that? Like let's say that they're, I don't know, playing a game or they want to jump directly to confirmation. This is why you would want either something on the server or you could have frontend logic that says, are we in an impossible state? \n\n[00:10:55] Just use Zod to validate that and basically kick them out if they're not supposed to be on that part of the URL or if the state is just inconsistent with what is expected in the application. >> Speaker 2: I think that's why partly on the reducer you always have the default just basically return whatever it was back at them so that there's no actions taken that they would want to be able to get into. \n\n[00:11:26] >> David Khourshid: Right, right, exactly. And that's another good point about reducers is that potentially you could limit when actions actually should change the state. And that's something that I haven't dived too deep into. But right now, when we're using useReducer a lot, it's action first. But if you do it state first, then that's another way that you could prevent impossible states. \n\n[00:11:49] So for example, if I'm loading data, but I have a back button and I go back to the form where I just enter my input and everything like that. And I have an action that's like, all right, I got the search results, take me to the results page. \n\n[00:12:08] What should actually happen is I should only be able to go there if I'm in a state where I'm waiting for results. If I'm not in that state, like if I'm on the first step, where I'm just entering search information, then that action should be completely ignored. So that's a core principle of state machines just preventing impossible transitions like that."
    },
    {
      "number": 28,
      "title": "Server State Management with TanStack Query",
      "slug": "server-state-management-with-tanstack-query",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/server-state-management-with-tanstack-query/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: All right, so I want to briefly talk about fetching data because when you look at your applications, or at least many applications in React that I've seen, some of the most, I don't want to call it egregious, but some of the most common uses of Use state and Use effect are for fetching data and React. \n\n[00:00:23] It gives you actually a couple patterns or, sorry, React naturally gives you a pattern right now to prevent that. And that's using Suspense and using server components. Now if you don't have the ability to do that, like you're not on the latest version of React and that's not possible. \n\n[00:00:44] One of the more common approaches that you could do is using a third party data fetching library. So I'm going to go to Fetch readme. Commonly we see this useEffect and useState dance when we're searching for results. You've probably seen this code all over the place. This is just a very common example of how you have accidental complexity. \n\n[00:01:15] This has almost nothing to do with the problem domain that we're working with. It's in fact the only line that matters is this one right here. Well, this one and the actual flight search. Everything else is just noise. And so this is an example of how it just makes things really confusing to work with, even though like it's an extremely common pattern. \n\n[00:01:37] So, what can we do instead? We can actually use a library like Tanstack Query. And so with Tanstack Query, it has so many features that if you were to build your own data fetching abstraction, some of these features are things that you might run into in the future and realize that. \n\n[00:01:58] All right, Tanstack Query already has this built in, such as being able to define how long to keep things in the cache or automatic retries and things like that. So how many of you have actually heard of or are using Tansat Query in your applications? All right, 50%, that's [LAUGH]. \n\n[00:02:21] Yeah, and I'm sure that many of you have honestly just done this Use effect pattern. And even this isn't perfect. Like we need to set let is is canceled to like false and then we need to do some cleanup. So return is canceled. True, this used to be like the way that you would fetch data and use effects the proper way. \n\n[00:02:47] But now instead of that, the more modern way is like const aborts controller. You set up an abort controller and then you have abortcontroller aborts. And then you could either pass it in natively if it supports it, or you could do something where if the signal is aborted, then return, it gets really confusing. \n\n[00:03:09] And these are things that you're typing over and over and over again. And that's why it's tempting to make your own abstraction or to just copy paste this entire thing. And even when you ask AI coding assistants, they're probably going to create a useEffect useState mess just like this for fetching data. \n\n[00:03:28] But instead of that, we could just use query. So with Tanstack query, it does require a query client, and I'll show you where that's set up, but you give it a query key. And so this is going to be an array that uniquely identifies the data that you're loading. \n\n[00:03:46] So we scope this, we're seeing that this is flights, and we pass in the flight search data so that if the flightsearch data changes and we refetch again, we know that we're not going to reach into the cache because there is no cache item for this. Or we're going to have to make a new search, which happens over here. \n\n[00:04:07] And honestly, these are pretty optional. There's also mutations if you want to like, instead of fetching within a component, you want to just fetch directly when some, when some side effect is supposed to happen."
    },
    {
      "number": 29,
      "title": "TanStack Query Exercise",
      "slug": "tanstack-query-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/tanstack-query-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: In this exercise we're going to actually be using Usequery and replacing a bunch of useEffects and use date to fetch data with Tanstack Query. If you need a reference to where or like how to do it, then I would really recommend you go to tanstack.com query I believe. \n\n[00:00:24] And there are some starter guides over here. It gives you an overview of how to fetch data using Tanstack Query. So we'll take a couple minutes and we will refactor this component. So if we go to Fetch page, there's a couple of places where we're fetching data. You could see it over here, we're fetching flights, and over here we're fetching hotels. \n\n[00:00:51] So what I want you to do is convert this to using Tanstack query just to get a feel for using third party libraries for fetching data and how much boilerplate code it actually removes. All right, so here's how we could get rid of all of those useEffects and use dates and just make our code a lot simpler. \n\n[00:01:16] The first thing that we need to do is, and this is honestly the tiniest bit of boilerplate for React's query, but it's required by it, otherwise it will yell at you. You want to first create a query client. And this comes from Tanstack React Query. And this query client is the central place where it's basically going to hold that cache. \n\n[00:01:42] So you might think of Tanstack, like React Query as, as a data fetching library. It's actually not. It's more of a local cache library that just works really well with Async data, and that's sort of its primary use case. The other thing that you're going to want is a query client's provider. \n\n[00:02:06] And so this also comes from Tanstack Query, you pass the clients into it. And so what this is going to do is anything that uses Usequery, use mutation inside of your components, it's going to be able to read that query client and use it. So now let's get rid of these useEffects. \n\n[00:02:26] So let's look for this one. We're loading flights over here. It's time to make some code disappear. So we're going to get some stuff. We don't know exactly what this is yet, but we're going to use Query and the first thing that we're going to do is we're going to pass in the query key and this is just going to be our flights and we are going to put in our flight search. \n\n[00:02:57] So flightsearch and then we actually have to fetch the data. So that is our query function and we're going to pass in the flight search to it. And also I need to import this. And so this is going to give us a few very useful things. It's going to give us data, it's going to give us an error if there is an error. \n\n[00:03:22] And it's also going to give us some very handy booleans. So it has is loading. And if you really want to, instead of using the Booleans, you could use status, and that way is loading equals, status equals, and then you have error pending or success. So internally, Tan Stack Query maintains its own state machine for dealing with these requests, but for now we're just going to use is loading. \n\n[00:03:54] And so now we could get rid of this state. And, and we don't need this anymore or this or actually we don't need any of this because if we just rename this to flights, we no longer need this or this. And now we're just using Tanstack query for it. \n\n[00:04:18] Now, before I save this, I want to show you the difference between, you know, using Tanstack query and not using it. So if I go to fetch. Error has already been, all right, actually I'll just do this. I'll save it. Anyway, so we have error over here. It's gonna be error message, I think that that's good. \n\n[00:04:46] Okay, so now let's search for a flight to Tokyo departing soon. So we are going to get our flights. Now, if we go back to search and we don't change anything and we search, we instantly get the results again. And the reason is because it's cached. So this is one of those things where this would require even more code to implement. \n\n[00:05:12] And it is a very useful feature to have so that you don't make unnecessary API requests and you don't keep your users waiting for too long. So now when you select a flight and you change the hotel, if I go back to search and I search for hotels again, it's going to keep on searching. \n\n[00:05:33] And that's because we didn't implement a caching layer. And so it's not using react query, it's just going to keep fetching over and over again. But hopefully you could see that we removed a lot of useStates. We removed a big useEffect and we're just replacing that with a single usequery call. \n\n[00:05:55] It's like one of those things that people wish were just built into React because it's such a useful library. >> Speaker 2: One. Major difference between the older versions of React Query and the newer one is the is pending versus is loading. Because used to be is loading was just like anytime it was fetching data, but then they changed it to be pending. \n\n[00:06:23] Because there are times when you wanted to show a loader if it's like refetching versus when it's just initializing the first fetch and then just showing whatever's cached and then updating with whatever is cached. And so I had to make sure that when I was upgrading in that process that I used the proper key. \n\n[00:06:47] >> David Khourshid: Yeah, that's a very good thing to point out, there is a subtle difference. Thankfully, if you do hover over, it does tell you when each one will be active, and I think this one is different. Is true whenever the first fetch for a query is in flight, right? \n\n[00:07:02] >> Speaker 2: Yep, so it's a combination of both isFetching and isPending. >> David Khourshid: Yeah. Awesome. >> Speaker 3: As someone new to React Server components and Next js, it sounds like I'd reach for Tanstack query for any use client component, or does this also play well with server components? >> David Khourshid: I would say it's either or. \n\n[00:07:25] So with server components, the idea is that you're awaiting your data like in the component itself, and actually let me search for. Let me search for one of these. So something that I forgot to mention is that this entire app, besides just the exercises, is a flight itinerary booking app that I have started to build. \n\n[00:07:53] So it is messy, but it is also a good way of just putting you into a real world app that is in progress. So I do invite you to like, if you want to finish the app, play around with it. It's something that I did start, but this would be an example of using a server component. \n\n[00:08:11] So notice that there's no use clients, we have an itinerary page. I'm using a database to just get my itineraries and I'm actually awaiting this directly inside the component. So yeah, you could also use Suspense. I believe I have. Yep. I have one page where I am using Suspense and this is for like showing the flight results and actually let me just demonstrate that to you real quick. \n\n[00:08:40] Again, this is extremely half built, but let's say that we have a trip to Minneapolis and we're just doing stuff. We create the itinerary, and then we want to add a destination. So this is just like a fully featured or a fully featured app in progress. And then like if you're booking flights, you're going to see suspense in action because we have this, we have our flights, and this all happened within the same page. \n\n[00:09:17] So. Yep, there's suspense in action as well. Then we have some hotels for us to choose from. Yeah. So I would really recommend reading the react docs on using server components and suspense. And there's also a few front end master's courses on that too that go much more in depth than I will in this course."
    },
    {
      "number": 30,
      "title": "Syncing with External Stores",
      "slug": "syncing-with-external-stores",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/syncing-with-external-stores/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Great. So I want to quickly talk about just two other things and the first thing I want to talk about is the USync external store hook, which I really like. Yeah, so USync external store is one of those really underrated hooks. It's one of those hooks that are used in third party libraries mostly and only sometimes in real world applications. \n\n[00:00:27] Although once you see it and once you get used to it, which we're going to practice in this exercise, you're going to see just how useful it can be and how it actually reduces the amount of code that you have to write. One of the common patterns that we do with UseState and UseEffect and managing state with something that is changing externally is this imperative flow of, for example, if we're checking if we're online or not, we had this UseEffect, which is subscribing to the window online offline listener. \n\n[00:01:00] This example is also in the React docs and we're setting is online based on whether the navigator is online or not. And then we're returning that we're saying if it's online, show online, otherwise show offline. And it's going to work fine, but there might be potential problems with this approach, such as race conditions or hydration mismatches, which is one of those annoying errors that you get with Next js, which is a combination of server-rendered pages and dealing with the client side. \n\n[00:01:39] One of the things that you could do is actually use the USYncexternal store hook, and this actually works really well with browser APIs. The USYnce external store hook takes three arguments. The first one is a way to subscribe to some external source and so it takes a callback. \n\n[00:01:58] And so you could just, for example, when it's online or offline, you could just pass in that callback and then there is a function for getting whatever the current snapshot is according to the client. And then this one is pretty important and this one is alone responsible for just solving a whole host of hydration errors, which if you've run into them with next JS, they are pretty annoying. \n\n[00:02:26] But using USync external store allows you to avoid them by providing a consistent server snapshot where in this case we're assuming it's online. And as long as this stays consistent between the server and the client, then it's going to work with USync external store and, and next JS won't yell at you. \n\n[00:02:48] And then of course in this one we're just returning if it's online or not, and that's really all there is to it. To the USync external store hook."
    },
    {
      "number": 31,
      "title": "useSyncExternalStore Hook Exercise",
      "slug": "usesyncexternalstore-hook-exercise",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/usesyncexternalstore-hook-exercise/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: Okay, so in this exercise, we are syncing with an external store, and this external store is responsible for showing us a bunch of flight information. And it updates every second or so. You could see that some of the statuses are changing, some of the gates are changing. \n\n[00:00:20] This is a very chaotic airport that we're modeling over here. And what's happening is we're subscribing to this store to get these flight updates. The way that we're doing that is we're using useEffect to subscribe to this flight store, and we're setting the flights and putting them in use date and then we're returning the flights. \n\n[00:00:43] So just to get used to USYNC external store, I want you to take a couple of minutes and refactor this so that instead of UseState and UseEffect, we use the USYNC external store hook. All right, so let's refactor this. We're going to use SYNC external store. And again, it's going to take three arguments. \n\n[00:01:10] The first one is a way to subscribe to the flight store. And so we could just pass subscribe here because looking at the implementation, we already have like this way of subscribing and unsubscribing. So whenever we get new data, it's going to basically add the callback to the listeners and then call those listeners. \n\n[00:01:33] So we get those flights and we also have a way of getting the snapshot. So flightStore.getSnapshot. And since the snapshot is going to be the the same whether it's the client or server, we could also safely pass in this snapshot for here as well. And typically when you're using this with external systems and not browser APIs, you'll realize that the client and the server snapshot are going to be the same. \n\n[00:02:02] So the return value of here is what we're subscribing to. So we could say const flights equals USYNC external store with all of that data, and we're going to see that the end result is pretty much exactly the same. So we're still subscribing, but we have a much more concise way of doing that."
    },
    {
      "number": 32,
      "title": "Testing Reducers vs Testing Components",
      "slug": "testing-reducers-vs-testing-components",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/testing-reducers-vs-testing-components/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: For the last exercise, I want to talk about testing, because testing is very important, of course, as you all know. And when we're testing application logic, this is where all of the principles that we talked about really come into play. Where events are the actual source of truth, state updates are immutable and represented in pure functions, and also doing things like having predictable declarative side effects and normalized data, et cetera. \n\n[00:00:36] So usually when we're testing react applications, we're really testing the ui. That's the normal de facto way of testing. We're using testing library or vTest, we're rendering our application and, and then we're clicking buttons or filling out fields virtually just to see that everything is working. Now these kinds of tests, which I consider to be a form of end to end tests, are very valuable. \n\n[00:01:05] So I do recommend, like, don't get rid of them, they're extremely useful. However, they can distract from testing the actual pure business logic. And so this is why when you have a, a pure function that represents your business logic, it is extremely easy to test, because the whole premise of testing is that given an input, we want some sort of expected output when it goes through this function. \n\n[00:01:35] And that's exactly what a reducer can provide to us. So for instance, if we have a booking reducer and we pass in the initial state and the action that happens, it doesn't matter how that action happens, we just want to know that the actual business logic is correct. \n\n[00:01:53] So we can assert that different parts of the new state are correct. So that we could say the current step should be hotel after this, and that when we pass in the mock flight, then the selected flight is that mock flight. So just to give you an example, we have a booking reducer here. \n\n[00:02:16] And again, you can test the UI if you want to, but when the app logic changes, for example, let's say that you add more steps to the booking flow, or you change some sort of internal logic within the booking reducer, then the UI tests actually become pretty difficult to update. \n\n[00:02:34] And that's because you're not just dealing directly with logic, you, you're dealing with ui, which sort of masks the underlying logic. So if we take a look at the booking reducer, we see a lot of different steps over here. Like we're searching flights, then we're searching the hotels, we're updating the hotels. \n\n[00:02:54] There's just many different ways that we could go through this flow. And so once we have the initial state, we could actually just test entire flows, especially with the help of AI assisted coding tools and just use that pure function to ensure that we are on the correct state given the events that are passed in. \n\n[00:03:18] So that's why I actually like doing let state instead of const state, because then I could just reassign it. So we could say state equals booking reducer. Let's make a mock flight. So const model mockFlight. So let's say that we select a flight from a mock airline. We could actually continue through this and just continue to the entire flow. \n\n[00:03:43] So we can expect that the next step is the hotel search and that the selected flight is the mock flight. Then when we go back to change flight, we could assert that we're actually going this is not the happy path. But we could assert that when the user decides to go back, we're on that previous step and then we could just keep going through there, maybe doing a mock hotel, and we could just basically test entire flows this way. \n\n[00:04:11] And so this is something where even if your UI completely changes, the testing logic for this application is going to be exactly the same. And so that's why when you're thinking about doing unit tests, really consider putting application logic into that valuable bucket of things that you should unit test. \n\n[00:04:37] So as you can see, it's very straightforward. We're dealing only with domain specific things and we're not really worried about how do we get to different buttons or inputs in the ui. So I consider testing reducers a very valuable approach because you can test flows like this. Any questions on testing application logic? \n\n[00:05:03] >> Speaker 2: Have you had experience with Cursor writing unit tests and seeing if it has made some relatively improvements on how it does implementation of your tests? >> David Khourshid: I think that when you keep things simple, for example, I let cursor generate all of these tests over here and they all look to be correct. \n\n[00:05:28] Cursor is really good at that, especially because it does have reference to this booking reducer. Everything is in one central place and it understands really well what the flow of this is going to be. However, when it comes to actual UI tests, I've seen that it does get some things wrong a lot. \n\n[00:05:47] Or really it actually makes the wrong assumptions. So if your UI is in any bit difference than what Cursor would expect from a normal ui, then it might suggest clicking the wrong thing or filling in the wrong field, or just doing whatever it wants with the tests. And the reason for that from an LLM perspective is that when you're dealing with UI, you're dealing with multiple components in multiple different files. \n\n[00:06:17] And so Cursor has to go through the extra step, if it even does that at all, of piecing together all these files and relating that data together rather than just having it all in one place."
    },
    {
      "number": 33,
      "title": "Wrapping Up",
      "slug": "wrapping-up",
      "url": "https://frontendmasters.com/courses/react-nextjs-state/wrapping-up/",
      "section": "",
      "transcript": "[00:00:00] >> David Khourshid: All right, well, I hope that you all enjoyed this Frontend Masters state workshop. And learned a lot of principles, techniques and patterns that you could use in not only your React applications, but basically any other front end application, or even backend, to improve the way that you manage states. \n\n[00:00:20] And to improve the way that you make your code understandable and easy to maintain and update, especially as it scales. Again, scale isn't about lines of code or millions of users or things like that. Instead, scale is about how quickly can you iterate on your code base as the number of features increase or get more complex, and how maintainable is your code base, especially as you add more team members and you introduce new tools and new techniques into your code. \n\n[00:00:57] So we learned a lot today. We went through anti patterns, just common things that you could avoid in React applications. We talked about principles like diagrams and how things like entity relationship diagrams, sequence diagrams and state machines are not only useful for databases or server side applications, but also for front end applications. \n\n[00:01:18] We did a lot of work on refactoring things into using finite ST states and reducers and we talked about how we could reduce the amount of code that we write by just using the native form data API with forms and using server actions with React 19 using the URL for state so that we could persist the state, and also using third party data fetching libraries like Tanstack Query or React Query so that we could really simplify all of those use states and use effects that we used before. \n\n[00:01:53] We talked about some painful things like the chaining cascading effects that caused so many problems and how we could use event driven architecture and reducers to really reduce the number of effects that we use. And we talked about other useful things such as using third party state management libraries, normalizing your data so that it is easier to work with the Use Sync external store hook, and of course testing your application logic at the very end. \n\n[00:02:24] So I hope that you all got a lot from this workshop. Remember, nothing in here is dogmatic. You don't have to refactor your entire applications after this. Instead I want all of these to be tools in your toolbox so that you could simplify your state or make it easier to create new features and just detect problems before they happen. \n\n[00:02:50] So thank you all very much."
    }
  ]
}